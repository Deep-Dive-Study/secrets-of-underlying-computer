![image](https://github.com/user-attachments/assets/5d0cee0a-b0ef-4fe0-a3fb-57a468eeb767)# 1.1 여러분이 프로그래밍 언어를 발명한다면?

CPU는 0과 1만 이해할 수 있다.

→ 멍청하지만, 간단한 연산을 매우 빠르게 처리할 수 있다.

### 0과 1만 이해하는 CPU를 이해시키기 위해 CPU 언어로 소통

- 천공카드

![image](https://github.com/user-attachments/assets/1e1e3ccb-d657-4eb7-9a9d-ce5593f89f6e)

- 소스 코드 (0,1)

![image](https://github.com/user-attachments/assets/232c9a6c-a64f-476c-b600-f3d78505304e)

### 어셈블리어 등장 (저수준 언어)

연구 끝에 CPU는 간단한 연산만 처리한다는 사실을 알게되었다.

→ 0,1로 이루어진 특정 작업들을 간단하게 인간의 언어로 대응시켰다

![image](https://github.com/user-attachments/assets/e28dd943-7c01-48a3-a6a4-9405e16ce5bc)

위의 코드가 0,1로 구성된 바이너리 변환 프로그램을 사용한다.

### 고수준 계층의 추상화

어셈블리어는 저수준 언어여서 세부 사항에 대해 신경을 써야 한다.

→ 추상적 표현을 구체적 세부 사항으로 변환 한다.

![image](https://github.com/user-attachments/assets/7fb04ec4-1c05-4f4c-bb2b-a4fdb00ea91f)

### 고수준 언어의 시작

저수준 계층의 세부사항의 공통사항을 확인한다.

- ~~하다면 @@ 한다. (if문)
- ~~할때까지 @@한다. (while문)
- 세부 사항만 차이가 있고, 반복된다. (매개변수와 함수)

코드가 많이 반복되다보면 중첩되는 경우가 발생한다. → 재귀로 표현한다.

### 컴퓨터가 재귀를 이해하도록 만들기

재귀 구분에 작성된 코드를 트리 형태로 표현한다. 

즉 구문 트리 형태로 표현한다.

![image](https://github.com/user-attachments/assets/083d6289-28b5-40be-8b71-857b4d7edf50)

위의 코드를 아래 트리로 변환한다.

![image](https://github.com/user-attachments/assets/9f29b202-ed5d-4084-91b8-be80876b449a)

리프노드의 표현이 매우 간단해서 번역하기만 하면 부모노드에도 적용이 가능하다.

이 구문트리를 기계 명령어로 변환하는 것을 **컴파일러**라고 한다.

### 해석형 언어의 탄생

각 CPU의 명령어 형식이 달라 문제가 발생했다.

→ **표준 명령어 집합을 정의해서 CPU 기계 명령어 실행과정을 모방하는 프로그래밍을 작성한다.**

CPU 시뮬레이션 프로그램에 인터프리터라는 가상머신을 생성하여 실행 코드를 해석하도록 한다.

![image](https://github.com/user-attachments/assets/08d0bab0-ac5b-4eda-9410-804076464eec)

이렇게 C/C++ 처럼 기게 명령어로 번역하여 CPU에 넘기거나, 자바처럼 byte code로 변경하여 가상 머신으로 넘겨 실행하는 방법의 고급 언어가 탄생한다.

고급 언어는 추상적 표현이 뛰어나서 사용하기 쉽지만 저수준 계층 제어 능력이 떨어져 일부는 어셈블리어로 작성된다.

# 1.2 컴파일러는 어떻게 작동하는 것일까?

![image](https://github.com/user-attachments/assets/96b3cfb0-3f24-4c74-9173-577dc4db68d5)

컴파일러는 번역기 일 수도 텍스트 처리 프로그램일 수 있다.

컴파일 처리 순서

1. 각각의 토큰 추출하기
2. 중간코드 생성
3. 어셈블리어 코드 생성

### 1. 각각의 토큰 추출하기

소스코드의 각 항목을 잘게 쪼개어 관리한다.

- 키워드 : 각 항목을 쪼갠 것
- 토큰 : 키워드와 관련 정보를 결합한 것 (int라는 키워드와 int의 정의)
- ex) while을 예로 든다.
    - while 이후 (boolean) 표현식이 와야한다.
    - 그 이후 { } 블럭이 있어야 한다.

**컴파일러가 구문 해석하는 구조**

![image](https://github.com/user-attachments/assets/a0b7ef23-58b0-48e9-b6f7-c4d3d1ba04fe)

### 2. 중간코드 생성

구문을 생성하고, 구문 트리에 이상이 있는지 의미 분석(semantic analysis)를 한다.

이후 좀 더 다듬어진 형태인 중간코드(Intermediate Representation Code)를 생성한다.

![image](https://github.com/user-attachments/assets/e25e635c-4389-4fa7-9127-5b808ad71c90)

### 3. 어셈블리어 기반 코드 생성

중간 코드를 어셈블리어 코드로 변환한다.

![image](https://github.com/user-attachments/assets/ef1a3bee-c71a-46b6-b63a-d50d6e48fc7e)

이렇게 각 소스 코드를 컴파일 하게되면 .o 라는 확장자를 가진 파일로 변환된다.

이를 대상파일(object file)이라고 한다.

여기서 끝이 아니라 대상파일들을 병합하는 link라는 과정이 더 있다.

# 1.3 링커의 말할 수 없는 비밀

### **동적 라이브러리와 정적 라이브러리**

**정적 라이브러리 (Static Library)**

컴파일 시점에 애플리케이션 코드에 통합되는 라이브러리이다. 보통 `.lib`(Windows) 또는 `.a`(Linux/Unix) 파일 형식으로 제공된다.

**사용 상황:**

- 배포 환경에서 종속성을 최소화하려는 경우.
- 실행 속도가 중요한 경우.
- 애플리케이션이 라이브러리 코드의 특정 버전과 함께 동작해야 할 때.

**동적 라이브러리 (Dynamic Library)**

실행 시 애플리케이션이 필요할 때 로드되어 사용하는 라이브러리이다. 보통 `.dll`(Windows), `.so`(Linux), `.dylib`(macOS) 파일 형식으로 제공된다.

**사용 상황:**

- 여러 애플리케이션이 동일한 라이브러리를 공유할 때.
- 런타임 중 업데이트가 필요한 경우.
- 메모리 사용량을 최적화해야 하는 경우.

### **주요 차이점**

| **구분** | **정적 라이브러리** | **동적 라이브러리** |
| --- | --- | --- |
| **통합 시점** | 컴파일 시 통합 | 실행 시 로드 |
| **파일 크기** | 실행 파일 크기가 커짐 | 실행 파일 크기가 상대적으로 작음 |
| **업데이트** | 다시 빌드해야 업데이트 가능 | 바로 적용 가능 |
| **공유** | 각 애플리케이션이 라이브러리 복사본을 포함함 | 여러 애플리케이션이 하나의 라이브러리 공유 |
| **성능** | 빠름 | 약간 느림 |
| **호환성** | 컴파일 환경에 강하게 종속 | 런타임 환경에 강하게 종속 |
| **컴파일시 통합 방법** | 링커가 필요한 함수만 추출하여 실행 파일에 포함 | 동적 링커가 실행 파일이 요청하는 라이브러리를 찾아 로드한다.
런타임 환경에 호출할 때 메모리 매핑 또는 심볼 해결이 이루어짐 |

### 링커가 일하는 방법

컴파일러가 생성한 여러 파일을 하나로 묶어 최종 실행 파일을 생성한다.

1. 종속성이 올바르게 설정되어 있는지, 종속된 모듈에서 사용 가능한지 확인한다.
외부 심벌에 대해 실제 구현이 단 하나만 있어야 한다. 이를 찾아내는 과정을 심벌 해석이라고 한다.
2. 각 실행 파일을 합쳐 하나의 최종 실행 파일로 만든다.
3. 소스 파일에 다른 모듈에 정의된 내용을 참조할 때 해당 함수의 메모리 주소를 정확히 알 수 없기 때문에 일단 표시해두고 넘어간다. 이후 링크 과정에서 링커가 실제 메모리 주소로 대체한다. 이를 재배치 라고한다.

**심벌 해석**

전역 변수와 함수의 이름을 포함하는 모든 변수의 이름이 단 하나만 존재하는지 확인하는 것이다.

- 링커단계에서 기계 명령어 실행을 위한 데이터를 생성한다.
    - 명령어 부분(코드 영역) : 소스 파일에 정의된 함수에서 변환된 기계 명령어가 저장된 부분
    - 데이터 부분(데이터 영역) : 소스 파일의 전역 변수가 저장되는 부분
- 컴파일러는 소스 파일마다 외부에서 참조 가능한/참조 중인 심벌이 어떤 것인지 심벌 테이블에 기록한다.
    - 내가 정의한 심벌 (외부에서 참조 가능한)
    - 내가 사용하는 외부 심벌
- 심벌 테이블이 저장되는 과정
    
    ![image](https://github.com/user-attachments/assets/09de240f-7e0a-40f0-974a-10799eaf5d9b)
    
    - 심벌 테이블에서 외부 심벌이 **유일한 정의**인지 확인한다.

### 정적/동적 라이브러리, 실행 파일

정적 라이브러리 : 유틸리티 함수들을 헤더파일에 선언하여 제공하는 것

- 윈도우에선 .ib 리눅스에선 .a
- 소스 파일마다 단독으로 컴파일한다. (정적 링크)
- 이후 대상 파일들을 모아서 실행 파일을 만든다.
- 실행 파일 내부에 _start 심벌이 있으며, CPU는 이 심벌 주소에서 프로그램을 실행하는 데 필요한 기계 명령어를 찾는다.
- 정적 링크는 라이브러리를 실행 파일에 직접 복사하기 때문에 디스크와 메모리를 엄청나게 낭비할 수 있다.
- 라이브러리 코드가 변경될 때마다 다시 컴파일해야 한다.

동적 라이브러리 : 

- 윈도우에선 .dll 리눅스에선 .lib or .so
- 참조된 동적 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 실행파일에 포함한다.
- 실행 파일 내부에 동적 링크 관련 정보가 있으며, 이 정보는 동적 링크시에 사용 된다.
    - 컴파일 시점엔 필수 정보만 저장한다.
    - 이후 실제 프로그램 실행 시점에 동적 링크를 한다. (두 가지 방법)
        - 프로그램이 메모리에 적재될 때 링크 진행 (적재 도구 사용, 어떤 라이브러리를 참조하는지 컴파일러에게 명시)
        - 런타임 동적 링크 (dlopen, dlsym, dlclose등 함수)
        

동적 라이브러리의 장점

- 메모리와 디스크 공간을 대폭 절약한다.
- 코드 수정시에 동적 라이브러리만 컴파일하면 된다.
- 플러그인 구현 가능

동적 라이브러리의 단점

- 실행 시간이 조금 더 길어진다.
- 동적 라이브러리는 메모리에 단 하나만 존재하기 때문에 임의의 절대 주소를 참조할 수 없다. (간접 접근을 해야한다.)

### 심벌의 실행 주소 결정

어떤 코드가 함수를 호출하려 할때 그에 대응하는 기계 명령어는 다음 형태를 가진다.

```jsx
call 0x400xd6
```

컴파일러는 대상 파일을 생성할 때 foo 함수가 어느 메모리 주소에 적재될지 모른다.

→ 간단하게 0x00으로 지정하여 기록한다.

→ 0x00으로 기록한 부분에 .relo.text, .relo.data를 기록한다.

- .relo.text : 코드영역에서 해당 함수의 시작 주소 (위치)
- .relo.data : 명령어 관련된 데이터 저장

심벌 해석 단계에서 기게 명령어와 전역 변수가 메모리 주소를 결정한다.

이후 .relo.text를 읽어 기계명령어를 수정하여 실제 메모리 주소로 변경한다.

링커가 변수의 실행 시간 메모리 주소를 미리 알기위해 **가상 메모리**가 탄생했다.

### 가상 메모리

![image](https://github.com/user-attachments/assets/90ef5330-78bc-4fe9-90eb-8792f6e884fc)

모든 프로그램의 메모리 주소는 0x400000에서 시작한다. 따라서 심벌의 가상 메모리 주소를 확인할 수 있다.

0x400000에 접근할 때 실제 물리 메모리 주소는 어디일까? → 시스템의 메모리 페이지(mapping 정보)

가상 메모리는 프로세스 단위로 관리되어 A프로세스의 0x400000과 B프로세스의 0x400000가 다다.

# 1.4 추상화의 중요성

프로그래밍을 추상화 하면 고민할 필요 없이 추상화된 API에만 집중할 수 있다.

시스템도 CPU를 직접 제어할 수 없으니 추상화 하여 고급언어로 직접 제어한다.

- I/O : file
- 프로그램 : 프로세스
- 메모리와 파일 : 가상 메모리
- 네트워크 : 소켓
- 실행 환경 : 컨테이너
- CPU, OS, 응용 프로그램 : 가상 머신
