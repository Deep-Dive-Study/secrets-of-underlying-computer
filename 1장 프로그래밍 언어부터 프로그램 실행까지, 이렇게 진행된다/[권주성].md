# Ch1 프로그래밍 언어부터 프로그램 실행까지 이렇게 진행된다.
- 앞으로 프로그래머가 코드를 작성하고 / 실행할 때 어떤 일이 일어나는지 상세하게 알아볼 예정
- 프로그래밍 언어는 프로그래머가 컴퓨터 명령을 내리는 도구(컴퓨터 시스템의 일부일 뿐)
- 해당 언어가 어떻게 동작하고 실행되는지 이해하는 것은 컴퓨터 시스템을 이해하는데 매우 중요함
- 예를 들어
  - 컴파일러는 어떻게 코드를 기반으로 실행 파일을 생성(Build)할까?
  - 프로그래밍 언어는 어떻게 만들었을까?
  - 실행 파일은 왜 실행될 수 있을까?
  - 등등
 
- 컴퓨터의 밑바닥이 어떻게 동작하고 있는지 알아볼 예정이고, 이는 매우 흥미로운 여정이 될 것

## 1.1 여러분이 프로그래밍 언어를 발명한다면?
- 프로그래밍 언어를 이해하는 가장 좋은 방법은 프로그래밍 언어를 직접 만들어 보는 것임
### 1.1.1 창세기: CPU는 똑똑한 바보
- 인류는 간단한 스위치를 조합하여 복잡한 **`불 논리(boolean logic)`** 을 표현하는 CPU 라는 논리 계산 장치를 만듦
  - 사실, CPU 는 단순히 데이터를 한곳에서 다른 곳으로 옮기고 계산하고 다시 옮기는 동작 밖에 할줄 모름
  - 다만, 이러한 계산의 속도가 **`엄청나게 빠르다는 것`**

- **`Code`** 는 CPU에게 동작을 수행하도록 명령을 내리기 위한 기계가 이해할 수 있는 관점에서의 언어

### 1.1.2 어셈블리어 등장
- 인류는 CPU는 가산 명령어, 점프 명령어 등 겨우 몇 가지 명령어만 실행할 수 있다는 사실을 깨닫고
- 따라서 기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시킨 어셈블리어를 만듦

  ![CleanShot 2025-01-19 at 22 26 24@2x](https://github.com/user-attachments/assets/3b38248c-8e10-458d-982e-56f8668a3064)

### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 저수준 언어와 고수준 언어
- 저수준이라는 의미는 프로그래머가 모든 세부 사항에 대해 신경을 써야한다는 의미

  ![CleanShot 2025-01-19 at 22 27 14@2x](https://github.com/user-attachments/assets/640be681-0951-4dfe-a06b-47897352ae1d)

- 고수준으로 갈 수록 동작이 추상화되어 함수 형태로 제공됨

### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작
  - 함수와 매개변수를 통해 반복되는 부분을 최소화


### 1.1.5 인셉션과 재귀
- 수학에서 피보나치 함수의 수열 연산은 끝없이 중첩된 구조 -> 재귀와 동일

  ![CleanShot 2025-01-19 at 22 52 06@2x](https://github.com/user-attachments/assets/2a27a73f-e83e-4ae3-b9cf-52ecdaaa0cc9)

- 세상의 모든 코드는 아무리 복잡하더라도 결과적으로는 모든 구문으로 귀결됨 

### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기
- 나무가지에 나뭇가지가 연결된 형태를 보고 재귀를 연상할 수 있음

  ![CleanShot 2025-01-19 at 22 52 46@2x](https://github.com/user-attachments/assets/a2baca8b-4b50-441e-8bb8-ce5cb3c9c8a3)

- 따라서, 재귀 구문에 따라 작성된 코드를 트리(tree) 구조로 표현할 수 있음
  - 이를 구문 트리(syntax tree) 라고 함

    ![CleanShot 2025-01-19 at 22 54 01@2x](https://github.com/user-attachments/assets/824ba704-8e53-43ec-9120-c74239322b70)

### 1.1.7 우수한 번역가: 컴파일러
- 컴퓨터가 프로그래밍 언어를 처리할 때 구문 정의에 따라 트리 형태로 코드를 구성할 수 있음
- 이러한 구문 트리를 어셈블리어로 매칭을 시켜주는 역할이 필요함 이를, 컴파일러(compiler) 라고 함

  ![CleanShot 2025-01-19 at 22 56 25@2x](https://github.com/user-attachments/assets/35341515-a8ac-4e71-8966-28bbe98cf9a4)

### 1.1.8 해석형 언어의 탄생
- 각 CPU 마다 어셈블리어가 달라지는 상황이 발생함
- 이를 해결하기 위해 언어는 인터페이스 형태로 표준 명령어를 생성하고 각 CPU 타입 마다의 이를 수행하는 인터프리터가 만들어짐

  ![CleanShot 2025-01-19 at 22 58 38@2x](https://github.com/user-attachments/assets/9ec1a323-6393-4324-8ad3-15c98165550a)

