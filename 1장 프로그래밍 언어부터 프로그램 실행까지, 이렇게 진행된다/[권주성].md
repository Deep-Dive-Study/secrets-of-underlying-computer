# Ch1 프로그래밍 언어부터 프로그램 실행까지 이렇게 진행된다.
- 앞으로 프로그래머가 코드를 작성하고 / 실행할 때 어떤 일이 일어나는지 상세하게 알아볼 예정
- 프로그래밍 언어는 프로그래머가 컴퓨터 명령을 내리는 도구(컴퓨터 시스템의 일부일 뿐)
- 해당 언어가 어떻게 동작하고 실행되는지 이해하는 것은 컴퓨터 시스템을 이해하는데 매우 중요함
- 예를 들어
  - 컴파일러는 어떻게 코드를 기반으로 실행 파일을 생성(Build)할까?
  - 프로그래밍 언어는 어떻게 만들었을까?
  - 실행 파일은 왜 실행될 수 있을까?
  - 등등
 
- 컴퓨터의 밑바닥이 어떻게 동작하고 있는지 알아볼 예정이고, 이는 매우 흥미로운 여정이 될 것

## 1.1 여러분이 프로그래밍 언어를 발명한다면?
- 프로그래밍 언어를 이해하는 가장 좋은 방법은 프로그래밍 언어를 직접 만들어 보는 것임
### 1.1.1 창세기: CPU는 똑똑한 바보
- 인류는 간단한 스위치를 조합하여 복잡한 **`불 논리(boolean logic)`** 을 표현하는 CPU 라는 논리 계산 장치를 만듦
  - 사실, CPU 는 단순히 데이터를 한곳에서 다른 곳으로 옮기고 계산하고 다시 옮기는 동작 밖에 할줄 모름
  - 다만, 이러한 계산의 속도가 **`엄청나게 빠르다는 것`**

- **`Code`** 는 CPU에게 동작을 수행하도록 명령을 내리기 위한 기계가 이해할 수 있는 관점에서의 언어

### 1.1.2 어셈블리어 등장
- 인류는 CPU는 가산 명령어, 점프 명령어 등 겨우 몇 가지 명령어만 실행할 수 있다는 사실을 깨닫고
- 따라서 기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응시킨 어셈블리어를 만듦

  ![CleanShot 2025-01-19 at 22 26 24@2x](https://github.com/user-attachments/assets/3b38248c-8e10-458d-982e-56f8668a3064)

### 1.1.3 저수준 계층의 세부 사항 대 고수준 계층의 추상화
- 저수준 언어와 고수준 언어
- 저수준이라는 의미는 프로그래머가 모든 세부 사항에 대해 신경을 써야한다는 의미

  ![CleanShot 2025-01-19 at 22 27 14@2x](https://github.com/user-attachments/assets/640be681-0951-4dfe-a06b-47897352ae1d)

- 고수준으로 갈 수록 동작이 추상화되어 함수 형태로 제공됨

### 1.1.4 가득한 규칙: 고급 프로그래밍 언어의 시작
  - 함수와 매개변수를 통해 반복되는 부분을 최소화


### 1.1.5 인셉션과 재귀
- 수학에서 피보나치 함수의 수열 연산은 끝없이 중첩된 구조 -> 재귀와 동일

  ![CleanShot 2025-01-19 at 22 52 06@2x](https://github.com/user-attachments/assets/2a27a73f-e83e-4ae3-b9cf-52ecdaaa0cc9)

- 세상의 모든 코드는 아무리 복잡하더라도 결과적으로는 모든 구문으로 귀결됨 

### 1.1.6 컴퓨터가 재귀를 이해하도록 만들기
- 나무가지에 나뭇가지가 연결된 형태를 보고 재귀를 연상할 수 있음

  ![CleanShot 2025-01-19 at 22 52 46@2x](https://github.com/user-attachments/assets/a2baca8b-4b50-441e-8bb8-ce5cb3c9c8a3)

- 따라서, 재귀 구문에 따라 작성된 코드를 트리(tree) 구조로 표현할 수 있음
  - 이를 구문 트리(syntax tree) 라고 함

    ![CleanShot 2025-01-19 at 22 54 01@2x](https://github.com/user-attachments/assets/824ba704-8e53-43ec-9120-c74239322b70)

### 1.1.7 우수한 번역가: 컴파일러
- 컴퓨터가 프로그래밍 언어를 처리할 때 구문 정의에 따라 트리 형태로 코드를 구성할 수 있음
- 이러한 구문 트리를 어셈블리어로 매칭을 시켜주는 역할이 필요함 이를, 컴파일러(compiler) 라고 함

  ![CleanShot 2025-01-19 at 22 56 25@2x](https://github.com/user-attachments/assets/35341515-a8ac-4e71-8966-28bbe98cf9a4)

### 1.1.8 해석형 언어의 탄생
- 각 CPU 마다 어셈블리어가 달라지는 상황이 발생함
- 이를 해결하기 위해 언어는 인터페이스 형태로 표준 명령어를 생성하고 각 CPU 타입 마다의 이를 수행하는 인터프리터가 만들어짐

  ![CleanShot 2025-01-19 at 22 58 38@2x](https://github.com/user-attachments/assets/9ec1a323-6393-4324-8ad3-15c98165550a)


## 1.2 컴파일러는 어떻게 작동하는 것일까?
### 1.2.1 컴파일러는 그저 일반적인 프로그램일뿐 대단하지 않다
- 간단히 말해서, 고수준 언어를 저수준 언어로 번역하는 프로그램
  - 소스 파일을 실행 파일로 번역
  
  ![CleanShot 2025-01-26 at 04 25 58@2x](https://github.com/user-attachments/assets/3c4b55ef-a428-457c-beab-41be9ac2255d)

### 1.2.2 각각의 토큰 추출하기
- 컴파일러는 먼저 각 항목을 잘게 쪼갬
  - 각 항목이 가진 추가 정보를 함께 묶어 토큰이라고 함 

    ![CleanShot 2025-01-26 at 04 27 16@2x](https://github.com/user-attachments/assets/35ed8902-13d2-4b5a-bc1a-e041c7ec0f87)

- 이렇게 소스 코드에서 토큰을 추출하는 과정을 어휘 분석이라고 함

### 1.2.3 토큰이 표현하고자 하는 의미
- 컴파일러는 이러한 토큰을 의미를 가진 명령어로 변환하기 위해 문법 검사 진행하는데 이를 해석(parsing)이라고 ㅎㅏㅁ
  - 트리를 통해 구문에 따라 해석해 낸 구조를 표현함(구문 트리) 
  
  ![CleanShot 2025-01-26 at 04 29 51@2x](https://github.com/user-attachments/assets/cbcb6970-84a4-4aef-a1bd-5e379b5a1999)

- 해당 트리를 생성하기 위한 전체 과정을 구문 분석이라고 함

### 1.2.4 생성된 구문 트리에 이상은 없을까?
- 구문 트리에 이상이 없는지 확인함. 이를 의미 분석이라고 함

  ![CleanShot 2025-01-26 at 04 31 20@2x](https://github.com/user-attachments/assets/3c610928-67c6-4dd7-b214-3cd9a5bc2481)

### 1.2.5 구문 트리 기반으로 중간 코드 생성하기
- 의미 분석이 끝나면 구문 트리를 탐색한 결과를 바탕으로 좀 더 다듬어진 형태인 중간 코드를 생성함

  ![CleanShot 2025-01-26 at 04 32 14@2x](https://github.com/user-attachments/assets/3ae74de5-73a3-4303-b744-9ceb5329db62)

- 이 과정에서 추가적으로 최적화가 진행 될수 도 있음

### 1.2.6 코드 생성
- 앞선 과정이 완료되면 중간 코드를 어셈블리어로 코드로 변환함

 ![CleanShot 2025-01-26 at 04 33 25@2x](https://github.com/user-attachments/assets/a7b4dfe9-87f1-457c-bfbd-27c9335cdf42)

- 마지막으로 컴파일러는 이 어셈블리어 코드를 기계 명령어로 변환함

- 다만, 이 과정이 모든 과정이 끝난것은 아님. 각각의 소스 코드는 각각의 대상 파일로 변환이 되었지만, 추가적으로 해당 대상 파일간의 병합하는 작업이 필요함.
- 해당 과정을 링크라고 하고, 해당 작업은 링커가 수행함

## 1.3 링커의 비밀
### 1.3.1 링커는 이렇게 일한다
- 링커는 압축 프로그램이 파일 여러 개를 하나의 압축 파일로 묶어주는 것처럼, 컴파일러가 생성한 대상 파일 여러개를 하나로 묶어 하나의 최종 실행 파일을 생성하는 역할의 프로그램
  - 마치, 저자 여러 명이 각각 특정 부분을 맡아 챕터 별로 따로 집필한 경우, 개별 장을 묶어서 한 권의 책으로 출판할 수 있게 하는 역할
  - 필요한 대상 파일을 한데 모아 구성

- 심벌 해석, 실행 파일 생성, 재배치, 등의 작업 과정을 수행함

### 1.3.2 심벌 해석: 수요와 공급
- 심벌이란? 전역 변수와 함수의 이름을 포함하는 모든 변수의 이름을 의미
- 링커는 전역 변수만 신경씀
  - 다른 모듈에서 참조할 수 있는 변수에 대한 정보
  - 다른 모듈에서 정의한 변수를 참조하고 있다는 정보 
- 이러한 정보는 컴파일러가 알려줌
  - 심벌 테이블에 기록함
  - 대상 파일에 같이 저장해둠
  
  ![CleanShot 2025-01-26 at 03 56 11@2x](https://github.com/user-attachments/assets/1d1de638-1e5c-4c89-af3f-e3e6ce69fcd7)

### 1.3.3 정적 라이브러리, 동적 라이브러리, 실행 파일
- 정적 라이브러리란? 미리 컴파일이 완료된 라이브러리
  - 각각 소스 파일마다 별도로 컴파일 진행하고 링크로 연결 
  - 다시 컴파일할 필요 없이 링크 과정에서 그대로 실행 파일에 복제됨 

  ![CleanShot 2025-01-26 at 03 58 16@2x](https://github.com/user-attachments/assets/27005200-527a-414d-a840-4f2397cf5a65)

- 코드가 의존하는 외부 코드를 매번 컴파일 하지 않아도 되기 때문에 컴파일 속도가 빠름
- 이 과정을 정적 링크라고 함
  - 대상 파일을 한데 모아 각각의 대상 파일에서 데이터 영역과 코드 영역을 각각 결합하는 것 

  ![CleanShot 2025-01-26 at 03 59 12@2x](https://github.com/user-attachments/assets/51310999-c5fb-480c-a1f0-40d6adbb05e3)

  ![CleanShot 2025-01-26 at 04 00 27@2x](https://github.com/user-attachments/assets/d9316efc-9b5b-4cb5-ad90-87a796fdf285)

- 정적 라이브러리의 단점
  - 실행 파일의 용량이 늘어남
    - 별개로 컴파일 하기 때문에 각각의 표준 라이브러리 같은 경우 별도로 존재함. 즉, 중복이 발생하게됨
  - 정적 라이브러리에 종속된 프로그램이 변경되면 매번 다시 컴파일을 해주어야함

- 동적 라이브러리
  - 정적 라이브러리가 실행 파일에 라이브러리 내용을 모두 복사한것과 달리 참조된 동적 라이브러리의 이름, 심벌 테이블, 재배치 정보,등의 필수 정보만 실행 파일에 포함됨
 
  ![CleanShot 2025-01-26 at 04 04 54@2x](https://github.com/user-attachments/assets/e829f859-188a-4eaf-abac-d518f6f96014)

- 동적 라이브러리는 실제 프로그램의 실행 시점까지 링크를 미룸.
  - 프로그램이 메모리에 적재될 때 동적 링크가 진행됨
  - 프로그램 실행 시간 동안 직접 동적 링크를 실행할 수 있음(실행 시간 동적 링크)

### 1.3.4 동적 라이브러리의 장단점
- 장점
  - 동적 라이브러리가 의존하는 프로그램 개수의 상관 없이 동적 라이브러리의 복사본 하나면 됨
  - 해당 동적 라이브러리만 재 컴파일하면 됨
  - 해당 기능을 확장한 것이 플러그인임
  
- 단점
  - 프로그램은 정적 링크를 사용할때 보다 성능이 약간 떨어짐
    - 라이브러리의 변수에 접근할 때 간접적인 접근을 사용해야하므로
  - 종속성 문제로 프로그램의 설치와 배포에 대한 어려움이 있을 수 있음 

### 1.3.5 재배치: 심벌의 실행시 주소 결정하기
- 모든 변수나 함수에는 메모리 주소가 있음
  - 즉, 어셈블리어 단계에서는 변수 대신 메모리의 주소값이 할당됨
- 컴파일러는 일단 간단하게 변환해서 링커에게 역할을 넘김
  - 해당 정보는 대상 파일에 저장됨  

- 먼저 심벌 해석 단계를 진행함
  - 대상 파일에서 동일한 유형의 영역끼리 병합
  - 링크 과정에 오류가 없다고 확신할 수 있게됨 

  ![CleanShot 2025-01-26 at 04 14 06@2x](https://github.com/user-attachments/assets/88efaf79-718f-453f-99a1-80433efd5bd1)

- 심벌의 메모리 주소를 수정하는 과정을 재배치라고 함

  ![CleanShot 2025-01-26 at 04 15 02@2x](https://github.com/user-attachments/assets/effbe8a8-1931-4aa2-bad5-498035b84996)

- 이러한 과정이 가능한 이유는 가상 메모리 기능 때문임

### 1.3.6 가상 메모리와 프로그램 메모리 구조
- 일반적인 프로그램은 OS로 부터 별도의 논리적인 메모리의 형상을 할당 받게 됨
  - 이는, 실제 물리 메모리와는 다른 영역 MMU와 같은 하드 영역단에서 변환을 지원하기도 함
- 따라서, 모든 프로그램은 동일한 메모리 형상을 할당 받기 때문에 독립적으로 메모리 주소를 사용 가능함

  ![CleanShot 2025-01-26 at 04 18 10@2x](https://github.com/user-attachments/assets/e7d74428-3e6c-447c-a8b4-944570f87960)

## 1.4 컴퓨터 과학에서 추상화가 중요한 이유
- 앞서 가상 메모리 처럼 추상화 덕분에 우리는 매우 효율적으로 프로그래밍할 수 있게 됨
  - 반복 작업을 효율화함
- 추상화는 표현력을 크게 향상 시키고 의사소통의 효율을 높여줄 뿐 아니라 세부 사항을 노출할 필요가 없어 보호할 수도 있음

### 1.4.1 프로그래밍과 추상화
- 소프트웨어는 추상화를 통해 복잡도를 제어하는 방향으로 발전해왔음
  - 저수준 언어에서 고수준 언어로
  - 현대에 와서도 클라우드, 쿠버네티스, 등 많은 영역에서 추상화의 형태로 발전 중임

- 다만, 문제가 생겼을 때 구체적인 동작 원리를 모르기 때문에 해결에 어려움을 겪게 됨
  - 프로그래머를 남들과 구분 짓는 특징 중 하나가 이러한 저수준 계층에 대한 이해도 임. 따라서, 저수준의 동작 원리도 이해할 필요가 있음



