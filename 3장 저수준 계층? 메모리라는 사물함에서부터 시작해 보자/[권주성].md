# Ch3 저수준 계층? 메모리라는 사물함에서부터 시작해 보자
- 메모리는 매우 단순해서, `0과 1을 저장할 수 있는 사물함`에 불과함
  - 인간 두뇌의 단기적인 기억 저장소와 같은 역할
- 하지만, 인류는 온갖 창의성을 발휘하여 이 단순한 사물함에 힙 영역, 스택 영역, 가상 메모리, 메모리 할당, 등의 개념을 창조함

## 3.1 메모리의 본질, 포인터와 참조

### 3.1.1 메모리의 본질은 무엇일까? 사물함,비트,바이트,객체
- 사실 메모리는 `일반적인 사물함과 본질적으로 다르지 않음`
  - 메모리는 사물함 대신 **셀(cell)이라는 영역에 0과 1에 데이터만 보관할 수 있음**
  
    ![CleanShot 2025-02-16 at 01 30 23@2x](https://github.com/user-attachments/assets/9ab37577-5d7b-4c7c-a7e4-0cf4ddee7480)

- 1비트(Bit)는 예(yes)와 아니오(no), 참(true)과 거짓(false)와 같이 대비되는 두 가지 정보를 표현할 수 있음
  - 이를 기반으로 논리 회로를 구성할 수 있게 되었음
  - 1비트를 8개로 묶어서 1바이트(Byte) 표현하고, 보통 일반적으로 사용하는 단위임

- 모든 바이트는 메모리 내 자신의 주소를 가지고 있으며 우리는 이 주소를 일반적으로 `메모리 주소(memory address)`라고 함
- 이를 활용하여 메모리 주소 한 개를 사용하여 여러 개의 사물함을 찾을 수 있음(offset) 이를 주소 지정(addressing)이라고 함

- 인간은 메모리를 통해 0과 1의 여러 조합을 가지고 정수와 구조체, 객체와 같은 데이터를 표기하는 방법을 찾아냄
  - 예를 들어, 이진수로 정수를 표현하고, 아스키 코드라는 규칙을 통해 언어를 표현하는 등으로 **`정보의 조합으로 의미를 가지는 데이터를 표현`** 함   

### 3.1.2 메모리에서 변수로: 변수의 의미
- 메모리 주소를 사람이 읽기 쉬운 형태로 별칭을 붙인 것이 **`변수(variable)`** 라는 개념
  - 대수학에서 사용하는 방식처럼 `a=1` 와 같이 표기함
  - a 변수가 나타내는 숫자 1이 메모리 주소 n 에 위치하고 있다는 것을 의미

### 3.1.3 변수에서 포인터로: 포인터 이해하기
- 동일한 데이터를 메모리에서 계속 복사하여 사용하기 보다 메모리 주소를 반복적으로 (혹은 개념적으로) 사용하고 싶고, 이를 별칭을 통해 지칭하고 싶은 필요성에 의해 **`포인터(pointer)`** 라는 개념이 탄생함
  - 즉, 메모리 주소를 저장하고 있는 변수
  - 그전까지는 데이터를 복제하여 해당 메모리에도 저장하는 형태였음(값만 저장 가능한 상황)
  - 포인터는 메모리 주소를 더 높은 수준으로 추상화한 것

    ![CleanShot 2025-02-16 at 01 52 25@2x](https://github.com/user-attachments/assets/f11b8c11-515c-4bba-ab1b-ad8ee25ebe6a)

### 3.1.4 포인터의 힘과 파괴력: 능력과 책임
- 포인터를 다룰수 있다는 것은 메모리의 주소를 직접 제어 및 조작이 가능하다는 의미
- 그만큼 프로그래머는 저수준 계층을 고려하고 신경써야하기 때문에 복잡함. 또한, 오류가 다소 치명적일 수 있게 됨을 의미함

### 3.1.5 포인터에서 참조로: 메모리 주소 감추기
- **`참조(reference)`** 란, 메모리의 주소를 직접 제어할 수는 없지만, 메모리 주소와 같이 특정 메모리 영역에 대한 개념적(추상화 된) 표현, 별칭으로 제어할 수 있도록 제공한 것
- 따라서, 기존의 포인터와 유사하게 메모리 연산을 사용할 수는 없으나 특정 데이터를 참조하고 있음을 나타낼수는 있게 되었음
  - 동일한 데이터를 가르킬 수 있기 때문에 데이터를 복사할 필요가 없어짐 

- 참조는 포인터를 한번 더 추상화했다고도 볼 수 있음

## 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?
- `표준 프로세스 메모리 주소 공간 구조`
  - 코드 영역, 데이터 영역, 힙 영역, 스택 영역

  ![CleanShot 2025-02-16 at 01 55 53@2x](https://github.com/user-attachments/assets/6a509c1b-46d9-42e9-8365-9a2a7a837186)

### 3.2.1 가상 메모리: 눈에 보인는 것이 항상 실제와 같지는 않다
- 모든 각 프로세스는 동일하고 독립적인 메모리 영역/구조를 사용하는 것 처럼 보여지나, 실제로는 하나의 메모리안에서 복잡하게 뒤엉킨 채 실행되어지고 있음
- 이를 가능하게한 것이 **`가상 메모리(virtual memory)`** 라는 개념임
- `가상 메모리` 는 각 프로세스와 영역을 실제 메모리와 연결하고 있는 정보(페이지 테이블)를 바탕으로 **`메모리 영역을 추상화하는 개념`**

  ![CleanShot 2025-02-16 at 01 59 45@2x](https://github.com/user-attachments/assets/dbb6e76b-58a5-4432-9805-e02f8a14ba8f)

- 프로세스는 **동일한 크기의 `조각(chunk)`으로 나뉘어 물리 메모리에 저장됨**
  - 모든 조각은 물리 메모리 전체에 무작위로 흩어져 있음
  - 페이지 폴트, 단편화 문제, 등이 있음(https://habbn-unitystudy.tistory.com/46)

### 3.2.2 페이지와 페이지 테이블: 가상에서 현실로
- 가상 메모리를 구현하는 방법은 사실 단순함
- 가상 메모리와 물리 메모리 사이의 사상(mapping) 관계만 유지하면 됨
  - 이를 `페이지 테이블(page table)`이라고함 (MMU)

    ![CleanShot 2025-02-16 at 02 01 26@2x](https://github.com/user-attachments/assets/4613dc4d-8f16-4f5b-8b2b-f52e4dfb7c15)

- 이를 통해서 **`모든 프로세스들이 여러개가 동시에 표준적인 구조의 동일한 메모리 주소 공간을 독립적으로 사용할 수 있는 것`**

  ![Google Chrome 2025-02-16 02 06 05](https://github.com/user-attachments/assets/b602768f-dd0e-48e7-a7ef-29be935ba5ca)

## 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

### 3.3.1 프로그래머를 위한 도우미: 함수
- 함수는 가장 기초적이고 간단한 코드 재사용의 방식임
- 함수는 프로그래머가 구현의 세부사항을 감출수 있게 하기 때문에 일종의 추상화라고 볼 수 있음
- 함수는 어떻게 저장되고 호출은 어떻게 구현되어 있을까?

### 3.3.2 함수 호출 활동 추적하기: 스택
- 함수가 실행되는 궤적을 살펴보면 `후입선출(LIFO) 순서로 동작한다는 것`을 알 수 있음
  - 이진 트리의 탐색의 순회와 유사하다는 것을 알 수 있음
  - 즉, 이진 트리가 재귀 구현뿐 아니라 스택 구현에도 사용될 수 있다는 것을 알 수 있음

  ![CleanShot 2025-02-16 at 02 22 31@2x](https://github.com/user-attachments/assets/97a22456-46a8-4760-b2d9-7844deaee6ef)

  ![CleanShot 2025-02-16 at 02 22 17@2x](https://github.com/user-attachments/assets/02a49a21-058b-4c84-8352-e5c06734ad8a)

### 3.3.3 스택 프레임 및 스택 영역: 거시적 관점
- 각 함수는 자신만의 데이터를 보관할 영역이 필요한데 이를 **`스택 프레임(stack frame)`** 혹은 **`호출 스택(call stack)`**이라고함
  - 여기에는 매개변수, 지역 변수와 같은 정보가 포함됨
- 즉, 함수를 호출할때마다 일정 영역에 스택(프레임)이 생성되고 이는 함수 호출 깊이에 따라 계속 증가하게됨 (완료시 감소)
  - 재귀를 호출하면 위험한 이유( **stack overflow** )  

### 3.3.4 함수 점프와 반환은 어떻게 구현될까?
- 함수의 호출관계는 함수 A에서 B로 갔다가 반환시 다시 A로 되돌아 오는 형태
  - CPU가 연산하는 코드 영역이 달라짐을 의미. 즉, 특정 명령어로 점프함을 의미(제어권이 이전됨)

- 점프할 때 필요한 정보는 다시 반환하기 위한 정보와 점프를 하기 위한 정보가 두개가 필요함
  - `반환(return)`: 어디에서 왔는지에 대한 정보
  - `점프(jump)`: 어디로 가는지에 대한 정보 

- 함수 입장에서는 (함수 A → 함수 B)
  - 함수 A의 기계 명령어가 어디까지 실행되었는지
  - 함수 B의 첫 번째 기계 명령어가 위치한 주소가 어디인지

- 함수의 호출은 실행 단계(runtime)에서 호출하는 함수의 첫 번째 기계 명령어가 위치한 주소로 변환됨

  ![CleanShot 2025-02-16 at 02 33 05@2x](https://github.com/user-attachments/assets/37277010-8da8-4fe5-8f13-95ea4d9fb787)

- 함수 호출시에 지정한 함수로 점프하는 행동 외에 현재 호출한 함수 다음 명령어가 실행될 수 있는 메모리 주소를 현재 함수 스택 프레임에 넣어둠 

  ![CleanShot 2025-02-16 at 02 33 37@2x](https://github.com/user-attachments/assets/3a210010-9fe5-4143-abce-3210be770b09)

- 이를 통해 함수의 이동이 가능해짐

  ![CleanShot 2025-02-16 at 02 34 33@2x](https://github.com/user-attachments/assets/cb6528e4-5145-4957-8a21-1bed8d4a3665)

### 3.3.5 매개변수 전달과 반환값은 어떻게 구현될까?
- 매개 변수의 전달과 반환값을 가져오는 작업을 `레지스터`로 함
  - 함수 A가 함수 B를 호출했을때 함수 A는 매개변수를 상응하는 레지스터에 저장하며, CPU가 함수 B를 실행할 때 이 레지스터에서 매개변수 정보를 얻을 수 있음
  - 함수 B도 반환 값을 레지스터에 저장하고, 함수 B의 실행이 완료되면 이 레지스터에서 반환 값을 가져올 수 있음 

- 다만, CPU 내부의 레지스터 수는 제한 되어 있어, 레지스터 수가 부족한 경우에는 스택 프레임에 직접 넣어 새로 호출된 함수가 이전 함수의 스택 프레임에서 매개변수를 가져오는 방식으로 동작함

  ![CleanShot 2025-02-16 at 02 42 06@2x](https://github.com/user-attachments/assets/1ac90e83-af35-4623-a142-f084bc8dcd51)

### 3.3.6 지역 변수는 어디에 있을까?
- 함수 내부에서 정의된 변수는 `지역 변수` 라고 함
  - 해당 변수는 함수 외부에서는 접근이 불가능함 
  
  ![CleanShot 2025-02-16 at 02 43 39@2x](https://github.com/user-attachments/assets/60a5fe34-4afe-441b-8831-9ffccc98c139)

### 3.3.7 레지스터 저장과 복원
- 레지스터는 CPU 내부 리소스임(캐시와 같은 존재)
  - CPU가 함수 A와 함수 B를 수행할때 같은 레지스터를 사용한다면 문제가 생길 수 있음(덮어쓰기)  

- 해당 문제를 해결하기 위해서는 레지스터의 초기 값을 저장하고 다시 불러올 수 있어야함

- 이러한 정보 또한 함수의 스택 프레임에 저장됨

  ![CleanShot 2025-02-16 at 02 46 58@2x](https://github.com/user-attachments/assets/697dc48c-9316-4e4f-894e-603cb6b2dd0d)

- 따라서, 함수 실행이 완료된 후에는 스택 프레임에 저장되어 있는 초기 값을 상응하는 레지스터에 내용으로 복원하기만 하면됨

### 3.3.8 큰 그림을 그려 보자, 우리는 지금 어디에 있을까?

![CleanShot 2025-02-16 at 02 48 12@2x](https://github.com/user-attachments/assets/ca9c9546-1269-4edc-8638-4c81ec7ae563)

- 프로그래머는 다음과 같은 사항을 주의할 필요가 있음
  - 1. `너무 큰 지역 변수를 만들면 안됨`
    2. `함수의 호출 단계(depth)가 너무 많으면 안됨`

- 참고로 스택 영역과 힙영역 사이의 유휴 영역(free segment)에는 프로그램이 사용하는 동적 라이브러리가 해당 영역에 적재됨

#### 생각해볼법한 문제
- 매개변수가 많아 레지스터에 저장되지 못한다는 정보는 어떻게 알 수 있을까?
- 스택 영역에 증가와 감소는 구체적으로 어떻게 구현되고, 이를 구현하는 책임은 누구에게 있을까?

## 3.4 힙 영역
- 스택 영역은 함수의 생명 주기와 동일하며, 함수 종료시 안에 있는 데이터들은 무효화됨
- 그렇다면, 특정 데이터를 여러 함수에 걸쳐 사용해야하는 경우에는 어떻게 해야할까?

### 3.4.1 힙 영역이 필요한 이유
- 모든 범위에서 특정 데이터를 사용하려면, 전역 변수를 활용하면 됨
  - 전역 변수는 데이터 영역에 저장됨
  - 전역 변수는 모든 모듈에서 사용이 가능함

- 하지만, 특정 데이터를 모든 영역에 노출시키고 싶지 않은 경우에는 힙 영역에 데이터를 저장해야함
  - 힙 영역은 메모리 수명 주기를 프로그래머가 완전히 관리, 제어할 수 있는 영역임 
  - 그리고 언제 데이터를 요청할지 데이터를 저장하는데 얼마나 많은 메모리 영역을 요청할지 프로그래머가 직접 결정해야함

 - malloc 함수 혹은 New 연산자를 통해 힙 영역에 메모리를 요청하고, free 함수나 delete 연산자를 통해 해당 메모리를 반환함

### 3.4.2 malloc 메모리 할당자 직접 구현하기
- C/C++ 에서는 메모리 동적 할당과 해제 요청은 모두 전문적으로 힙 영역에 메모리를 할당하고 해제하는 프로그램에 전달되어 처리됨
  - 이 프로그램을 **`malloc 메모리 할당자`** 라고 함 

- 프로그래머는 직접 메모리 할당 기능을 구현할 필요없이 malloc을 호출하여 사용하면됨.
  - malloc은 C 표준 라이브러리에 존재 

- 메모리 할당자 입장에서는 적절한 크기의 메모리 영역을 제공하고 반환 받기만 하면 되고, 할당자는 메모리 영역에 무엇이 저장되는지까지 신경쓰지는 않음
  - 주요 기능 두가지
    - 메모리 할당
    - 할당된 메모리 반환  

### 3.4.3 주차장에서 메모리 관리까지
- 메모리를 관리할때 달성해야하는 목표
  - 비어 있는 메모리의 위치를 빠르게 찾아야함
  - 가능한 메모리를 효율적으로 많이 저장할 수 있게 관리해야함

   ![CleanShot 2025-03-02 at 00 38 36@2x](https://github.com/user-attachments/assets/196eaba6-3303-47ef-af90-46595e3b2843)

  ![CleanShot 2025-03-02 at 00 38 56@2x](https://github.com/user-attachments/assets/e16a2d7d-0aa0-44e6-b242-6d32ba8a604c)

- 문제는 요청하는 메모리 크기가 일정하지 않음

- 메모리 할당자의 두가지 핵심 과제
  - **`여유 메모리 조각 관리`**
  - **`여유 메모리 조각 할당 전략`**

### 3.4.4 여유 메모리 조각 관리하기
- 비어 있는 메모리의 위치를 빠르게 찾기 위해서는 메모리 조각을 어떤 식으로든 `조직화해서 할당 상태를 추적할 수 있어야함`
- 연결 리스트(linked list)를 통해 간단하게 구현해볼 수 있음
  - 모든 메모리 조각을 하나의 리스트로 관리
  - 다만, 해당 리스트에 내부에 정보를 기록할 수 없음
  - 왜냐하면, 해당 정보 또한 메모리 위에 저장되는데, 현재 구현하고자하는 기능이 메모리를 할당하는 기능이기 때문에 문제가 있음. 그렇다고 따로 영역만 두기에도 번거로움

- 따라서, **`메모리 사용 정보를 노드로 별도로 저장`**
  - `해당 메모리 조각이 비어 있는지 알려주는 설정 값`
  - `해당 메모리 조각의 크기를 기록한 숫자` 
  
    ![CleanShot 2025-03-02 at 00 50 20@2x](https://github.com/user-attachments/assets/2d45c497-0068-4e3a-9e79-c3e487e12814)

- 따라서, 메모리 조각에 대한 필수 정보를 저장하는 노드가 별도로 사용되기 때문에 일부 영역은 사용할 수 없음

### 3.4.5 메모리 할당 상태 추적하기
- `모든 메모리 조각은 머리 정보로 찾아갈 수 있음`
- 16은 크기, 0과 1은 사용 여부를 의미
  
  ![CleanShot 2025-03-02 at 00 52 34@2x](https://github.com/user-attachments/assets/eaef64ed-e8ae-4700-87e5-3fcfd04e130c)

### 3.4.6 어떻게 여유 메모리 조각을 선택할 것인가: 할당 전략
- 어떻게 여유 메모리 조각을 선택할 것인지에 대한 3가지 할당 전략이 있음

#### 최초 적합 방식
![CleanShot 2025-03-02 at 05 01 37@2x](https://github.com/user-attachments/assets/f8555233-7ec7-4da0-892b-b922bab3c28d)

- 매번 처음부터 탐색하다가 가장 먼저 발견된 요구사항을 만족하는 항목을 반환하는 전략
- 가장 단순함
- 항상 제일 처음부터 사용 가능한 메모리 조각을 찾으므로 메모리 할당 과정에서 앞부분에 작은 메모리 조각이 많이 남을 가능성이 있음
- 따라서, 다음 메모리를 할당하기 위해서는 더 많은 여유 메모리 조각을 탐색해야함

#### 다음 적합 방식
![CleanShot 2025-03-02 at 05 03 47@2x](https://github.com/user-attachments/assets/798a232e-6dae-4dd3-9781-9c6e7f309a0e)

- 최초 적합 방식과 유사하나 메모리를 요청할 때 처음부터 검색하는 대신 적합한 여유 메모리 조각이 마지막으로 발견된 위치에서 시작한다는 점에서 차이가 있음
- 이론적으로는 최초 적합 방식보다 더 빠르게 여유 메모리 조각을 탐색 가능함
- 다만, 다음 적합 방식의 메모리 사용률은 최초 적합 방식에 미치지 못한다는 것이 연구로 밝혀짐

#### 최적 적합 방식
![CleanShot 2025-03-02 at 05 06 57@2x](https://github.com/user-attachments/assets/61414b23-79f5-462b-918d-69005249eb15)

- 최적 적합 방식은 먼저 사용 가능한 메모리 조각을 모두 찾은 후 그중 요구 사항을 만족하는 가장 작은 조각을 반환함
- 메모리를 더욱 효율적으로 활용할 수 있음
- 다만, 매번 메모리를 할당할 때마다 사용 가능한 모든 메모리 조각을 탐색해야 하므로 빠르지 않음

### 3.4.7 메모리 할당하기
- 여유 메모리 조각을 찾았다면 해당 조각을 할당된 것으로 표시하고 헤더(머리) 정보 뒤에 따라오는 메모리 조각의 주소를 요청자에게 반환하기만 하면됨

  ![CleanShot 2025-03-02 at 05 10 06@2x](https://github.com/user-attachments/assets/240f560a-dda5-4351-8587-785425ccf2f6)

- 요청한 것보다 많은 용량을 반환하면 내부 단편화(fragmentation)가 일어남

  ![CleanShot 2025-03-02 at 05 11 18@2x](https://github.com/user-attachments/assets/dd6e4661-abdf-4bb0-b3a0-2d4ab2d04655)

  ![CleanShot 2025-03-02 at 05 11 30@2x](https://github.com/user-attachments/assets/3abb6a4e-5581-4767-98ed-1156f8973c2b)

- 이를 해결하는 방법은 여유 메모리 조각을 두개로 분할하여 앞부분은 할당하고 반환하고 뒷부분은 좀 더 작은 크기의 새로운 여유 조각으로 만드는 것임

  ![CleanShot 2025-03-02 at 05 12 56@2x](https://github.com/user-attachments/assets/cc160796-aa51-4dae-b6dd-ec154e11246d)

### 3.4.8 메모리 해제하기
- 메모리를 해제하는 것은 비교적 쉬움
- 사용자가 메모리를 해제하는 요청을 할때 매개 변수로 주소를 전달하면, 해당 주소의 헤더를 추출하여 사용중 표시를 바꿔주면됨

  ![CleanShot 2025-03-02 at 05 14 39@2x](https://github.com/user-attachments/assets/cd0e6734-178e-48af-bf15-6c605522fe81)

- 인접한 메모리 조각도 여유 메모리 조각인 경우 병합

  ![CleanShot 2025-03-02 at 05 15 40@2x](https://github.com/user-attachments/assets/5285a7e4-aa86-43e8-a471-0e364d49b736)

- 다만, 해당 작업을 메모리를 해제할 때 마다 즉시 병합하면 부담이 존재하기 때문에 적절한 타이밍으로 미루는 것이 좋음

### 3.4.9 여유 메모리 조각을 효율적으로 병합하기
- 해제 되는 메모리 조각에 앞, 뒤가 모두 비어 있는 경우
- 바로 뒤에가 비어 있는 경우는 비교적 알기 쉬우나 앞의 메모리가 비어 있다는 것은 알기 어려움
- 따라서, 이전 메모리에 대한 정보를 메모리 조각 끝에 다시 꼬리(footer)를 추가하여 효율적으로 알 수 있음

  ![CleanShot 2025-03-02 at 05 18 21@2x](https://github.com/user-attachments/assets/a1972d02-bce9-4f83-b556-355e7d6c2b14)

- 이전 조각의 꼬리 정보는 그 다음에 위치한 조각의 헤더 정보와 인접해 있어 현재 조각의 헤더 정보에서 4바이트를 빼면 이전 조각의 꼬리 정보를 획득할 수 있음
- 이를 통해 메모리 조각을 일종의 암시적 양방향 연결 리스트로 만듬

  ![CleanShot 2025-03-02 at 05 18 29@2x](https://github.com/user-attachments/assets/8f52becd-a351-469c-8291-ba04479bbdf2)

- 해당 구현 방식은 실제와는 차이가 있으며, 아직 최적화나 스레드 안전 문제, 등은 고려하지 않았음
- 단, 기본적인 원리는 동일함

## 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일
### 3.5.1 천지인과 CPU 실행 상태
- 프로그램이 실행되는 배경에 천지인에 해당하는 몇 가지 단계가 존재함

  ![CleanShot 2025-03-02 at 04 25 14@2x](https://github.com/user-attachments/assets/f36fd9ef-2754-4c3c-8f37-355fe62af09a)

  - x86 CPU는 네가지 특권 단계를 제공
  - 각 단계는 CPU의 여러 가지 동작 상태를 의미하며, 각 상태 별로 사용 가능한 명령어가 나눠져 있음
  - 가장 특권이 높은 커널 상태에서는 모든 기계 명령어를 실행할 수 있음
 
- 일반적인 시스템 기준으로 보면, **`사용자 상태`**와 **`커널 상태`** 로 나눠짐

### 3.5.2 커널 상태와 사용자 상태
- CPU가 운영 체제의 코드를 실행할 때 바로 커널 상태에 놓여짐

  ![CleanShot 2025-03-02 at 04 29 59@2x](https://github.com/user-attachments/assets/5eb61db2-6143-4eda-9943-8221d76ddf97)

- 반면에 프로그래머가 작성한 '일반적인' 코드를 CPU가 실행할 때는 사용자 상태에 놓이게 됨

  ![CleanShot 2025-03-02 at 04 30 54@2x](https://github.com/user-attachments/assets/6be5fe79-3c0b-4180-ab91-ebf5559d54a9)

  - 즉, 사용자가 작성한 코드는 특정 주소 공간에 접근하거나, 스스로를 죽이는(segmentaion fault) 등의 행동을 할 수 없음

### 3.5.3 포털: 시스템 호출
- 그렇다면, 프로그래머가 작성한 '일반적인' 코드로 운영 체제의 서비스를 사용하기 위해서는 어떻게 해야할까?
- **`시스템 호출(system call)`** 을 통해 운영 체제를 이용 가능함
  - 시스템 호출을 이용하여 운영 체제가 파일의 읽기 쓰기나 네트워크 데이터 통신과 같은 작업을 대신 처리해줌
  - CPU는 사용자 상태에서 커널 상태로 전환되어 운영 체제의 코드를 실행하는 방법으로 사용자 요청을 수행함 

  ![CleanShot 2025-03-02 at 04 34 50@2x](https://github.com/user-attachments/assets/16e92279-089b-40af-9477-ee089b6d7ced)

### 3.5.4 표준 라이브러리: 시스템의 차이를 감춘다
- 시스템 호출은 운영체제별로 차이가 있음
- 따라서, 저수준 계층간 차이를 감추는 일종의 **표준** 이 필요함
  - 그래야 프로그래머가 시스템을 고려하지 않고 동일한 코드를 작성할 수 있음
- C언어에서 해당 표준을 제공하는 것이 **`표준 라이브러리(standard library)`** 임 
- 표준 라이브러리는 실행 중인 운영 체제에 따라 대응되는 시스템을 호출을 선택함

  ![CleanShot 2025-03-02 at 04 39 47@2x](https://github.com/user-attachments/assets/25f2cb3d-d8ec-4f0f-87ab-f8ad6028ab81)

### 3.5.5 힙 영역의 메모리가 부족할 때
- 힙 영역을 제어하는 malloc에서 메모리가 부족하면 어떻게 해야할까?
- 힙 영역에 해당하는 메모리를 늘려야 함

  ![CleanShot 2025-03-02 at 04 42 01@2x](https://github.com/user-attachments/assets/4746e40b-1ea0-442f-b08f-3203bad3ee7c)

- 그러기 위해서는 brk 변수를 늘리는 요청을 운영체제에 해야함
  - 리눅스의 모든 프로세스는 **`brk(break)`** 라고 힙 영역의 최상단을 가르키는 변수가 존재함
  - 이 값을 위로 이동해서 힙 영역을 확장할 수 있음

  ![CleanShot 2025-03-02 at 04 42 54@2x](https://github.com/user-attachments/assets/79fecc9d-ddf2-45df-a95d-a58ab2af5e25)

### 3.5.6 운영 체제에 메모리 요청하기: brk
- 메모리 할당의 과정
  - **프로그램은 malloc을 호출하여 메모리 할당을 요청(사용자 상태, 표준 라이브러리)**
  - **malloc은 여유 메모리 조각을 검색하기 시작하고, 적절한 크기의 조각을 찾으면 이를 할당(사용자 상태)**
  - **malloc이 여유 메모리 조각을 찾지 못하면 brk 시스템 호출 등을 통해 운영 체제에 힙 영역을 늘려 달라고 요청(커널 상태)**
  
  ![CleanShot 2025-03-02 at 04 44 41@2x](https://github.com/user-attachments/assets/fb1a8623-9796-4944-9619-e7d6a646ecfa)

### 3.5.7 빙산의 아래: 가상 메모리가 최종 보스다
- `우리는 malloc을 통해 실제 메모리에 접근한다고 생각하나, 실제로는 가상 메모리 주소에 접근하고 있음`
- 즉, malloc을 이용하여 힘 영역에서 메모리를 요청하고, malloc 역시 운영 체제의 도움을 받아 힙 영역을 확장하지만, 이 힙 영역을 포함한 전체 프로세스 주소 공간은 모두 실제 물리 메모리가 아님
- 실제 물리 메모리는 할당한 메모리가 `사용되는 순간에 물리 메모리를 할당`하게 됨
  - 이때 가상 메모리가 아직 실제 물리 메모기와 연결되어 있지 않으면 내부적으로 `페이지 누락(page fault) 오류`가 발생할 수 도 있음 

- 사실 malloc도 메모리의 2차 할당된 것임

### 3.5.8 메모리 할당의 전체 이야기
- 사용자가 malloc을 호출하여 메모리를 요청했을 때 일어나는 전체적인 과정
  - malloc이 여유 메모리 조각을 검색하기 시작하고 적절한 크기의 조각을 찾으면 이를 할당
  - malloc이 적절한 여유 메모리를 찾지 못하면 brk 같은 시스템 호출을 통해 힙 영역을 확장하여 더 많은 여유 메모리를 얻게됨
  - malloc이 brk를 호출하면 커널 상태로 전환되는데, 이때 운영 체제의 가상 메모리 시스템이 힙 영역을 확장하는 작업을 시작함
  - 주의할 점은 이렇게 확장된 메모리 영역은 가상 메모리에 불과하며, 운영 체제는 아직 실제 물리 메모리를 할당하지 않았을 수 있음
  - brk 실행이 종료되면 malloc으로 제어권이 돌아가며 CPU도 커널 상태에서 사용자 상태로 전환됨
  - malloc은 이제 적절한 여유 메모리 조각을 찾아 반환
  - 우리 프로그램은 메모리를 성공적으로 요청했기 때문에 계속 다음 단계를 실행함
  - 코드가 새로 요청된 메모리를 읽거나 쓰면 같이 시스템 내에서 페이지 누락 인터럽트 (page fault interrupt)가 발생함
  - 이때 CPU는 다시 사용자 상태에서 커널 상태로 전환되며, 운 영 체제가 실제 물리 메모리를 할당하기 시작함
  - 페이지 테이블 내 가상 메모리와 실제 물리 메모 리의 사상 관계가 설정된 후, CPU는 다시 커널 상태에서 사용자 상태로 돌아가고 다음 처리로 넘어감

![CleanShot 2025-03-02 at 04 54 07@2x](https://github.com/user-attachments/assets/2b86d600-4b9d-4e96-8dd9-686cf83872b5)

## 3.6 고서능 서버의 메모리 풀은 어떻게 구현될까?
- 프로그래머가 메모리를 요청할 때 사용하는 malloc은 사실 범용 제품으로서 어떤 상황에서도 사용할 수 있음
  - 즉, 반대로 말하면 특정 상황에 맞게 최적화되어 있는 것은 아니라는 의미임 

- 특정 상황을 위해 자체적으로 메모리 할당 전략을 구현하기 위한 기술이 **`메모리 풀(memory pool)`** 임

### 3.6.1 메모리 풀 대 범용 메모리 할당자
- 메모리 풀은 표준 라이브러리인 malloc과는 다르게 응용프로그램의 일부임

  ![CleanShot 2025-02-27 at 00 48 33@2x](https://github.com/user-attachments/assets/4f3a708f-47c3-4058-84d8-da798f5db277)

- 메모리 풀은 보편적으로 사용하기 보다는 메모리 할당 성능을 최적화하기 위해 사용되기 때문에 범용성이 떨어짐
  - 특정 상황이 아닌 다른 상황인 경우에는 오히려 성능이 떨어지거나, 사용하지 못할 수 있음 

  ![CleanShot 2025-02-27 at 00 49 57@2x](https://github.com/user-attachments/assets/1d7c8876-c202-433e-9bc7-9646e1a76ef2)

### 3.6.2 메모리 풀 기술의 원리
- 메모리 풀 기술은, 한번에 큰 메모리 조각을 요청하고 그 위에서 자체적으로 메모리 할당과 해제를 관리하는 방식으로 표준 라이브러리와 운영체제를 우회함
  - 마치, 코틀린, 가상 스레드와 같은 추상화 계층인 느낌.. 

  ![CleanShot 2025-02-27 at 00 52 08@2x](https://github.com/user-attachments/assets/5a393d28-7b8a-485f-9933-2dbad854045b)

- 특정 사용 패턴에 따라 추가 최적화도 가능
  - 일부 객체를 미리 생성해두어 사용 가능(마치 커넥션 풀처럼)

- 프로그래머가 사용되는 메모리의 사용 패턴을 이해하고 사용하게 된다는 점이 이점이 됨

### 3.6.5 메모리 풀의 스레드 안전 문제
- 메모리 풀은 여러 스레드에서 동시에 접근 가능하기 때문에 스레드 안전 문제를 고려해야함

  ![CleanShot 2025-02-27 at 00 56 00@2x](https://github.com/user-attachments/assets/250755bf-4a02-48a7-8a8d-2fa4830729a8)

- 다만, 이렇게 하게되는 다중 스레드 상황에서 메모리 풀에 자주 접근해야하는 상황이 발생하면 경쟁이 치열해질 수 있음

- 이 문제를 해결하기 위해서는 각 스레드마다 존재하는 스레드 전용 저장소(TLS) 마다 별도의 메모리 풀을 넣어서 사용하는 것임

  ![CleanShot 2025-02-27 at 00 57 04@2x](https://github.com/user-attachments/assets/57115bd9-21b9-4024-8f35-6ab161d76f2f)

- 이또한 문제가 발생하는데 메모리의 생명 주기와 스레드의 생명 주기가 달라서 다른 스레드에서 해당 메모리를 계속 넘겨 받아 사용해야하는 경우에는 어떻게 해야할까?

#### 생각해볼법한 문제
- 메모리는 스레드 A에 속해 있는데 스레드 B에서 이를 해제해야하는 경우에는 어떻게 해야할까?
  - 메모리 해제 요청을 큐를 통해 전달하고 전용 해제 스레드를 두고 큐에서 메모리를 가져가서 처리하는 방식
    - 스레드 A에서 메모리를 할당하고, 해제 요청을 작업 큐에 넣음
    - 스레드 B는 큐를 모니터링하면서 해제 작업 수행
      - 혹은 다른 스레드에서 해제해야 할 경우 전역 큐를 사용하여 해제 요청을 넘겨 해제 전용 스레드가 이를 감지하고 메모리를 해제함

## 3.7 대표적인 메모리 관련 버그
- 메모리 관련 버그는 다중 스레드 문제와 함께 프로그래머를 괴롭히는 대표적인 난제임
  - 프로그램이 실행될 때 이상이 발견되면 문제를 일으키는 코드는 이미 깊숙한 곳에 멀리 떨어져 있어서 문제의 원인을 찾는 것이 어려움
 
### 3.7.1 지역 변수의 포인터 반환하기
![CleanShot 2025-02-27 at 01 14 14@2x](https://github.com/user-attachments/assets/397d67f3-caad-4b06-962d-e0a9a83aa294)

- 지역 변수는 해당 함수 스택 프레임 끝남과 동시에 사라지는 변수임
- 이를 반환하게 되면 이미 해당 주소는 값의 의미를 잃어버린 메모리 주소를 반환하게 됨
- 운이 좋아서 정상적으로 동작할 수도 있으나 올바른 방식이 아니며, 추후에 문제가 발생하게 되며 이는 원인을 추적하기 더욱 어려워짐

  ![CleanShot 2025-02-27 at 01 15 42@2x](https://github.com/user-attachments/assets/0b9fa49f-4f3d-4944-af70-31cf0a6abd65)

### 3.7.2 포인터 연산의 잘못된 이해 
- 포인터 연산에서 1을 더하는 것은 1바이트만큼 이동하는 것이 아니고, 단위 한 개만큼 이동하는 것을 의미함
- 이를 헷갈려서 잘 못 이동하는 사례가 종종 발생함

### 3.7.3 문제 있는 포인터 역참조하기
- 가끔 표준 입력으로 데이터를 입력 받을 때 다음과 같이 코드를 작성하는 실수를 범하는 경우가 있음

  ![CleanShot 2025-02-27 at 01 20 00@2x](https://github.com/user-attachments/assets/19787a92-85ff-4f08-ac2d-343033df8952)

- scanf 함수는 a 값을 주소로 취급하기 때문에 표준 입력에서 가져온 데이터를 해당 주소에 쓰게 되어 엉뚱한 주소에 데이터를 덮어쓰게 되는 문제가 발생할 수 있음

### 3.7.4 초기화 되지 않은 메모리 읽기
- 힙 영역에서 동적으로 할당된 메모리가 항상 0으로 초기화된다고 잘못 가정하여 문제가 발생하는 경우
- 실제는 초기화하지 않는 경우도 있기 때문에 무조건 적으로 0으로 초기화한다고 가정하면 문제가 발생할 수 있음

### 3.7.5 이미 해제된 메모리 참조하기
![CleanShot 2025-02-27 at 01 27 30@2x](https://github.com/user-attachments/assets/a77c62c2-7fcf-4a03-90f2-67cb0d2d20ad)

- 해당 코드는 힙 영역에 메모리 조각을 요청하고 정수를 저장해서 다시 해제함
- 하지만, 이어지는 코드에서 다시 해제된 메모리 조각을 참조하고 있음
- 이때, a가 가르키는 메모리에는 어떤 값이 들어가 있을지는 malloc 내부 작업 상태에 따라 다름 

  ![CleanShot 2025-02-27 at 01 28 48@2x](https://github.com/user-attachments/assets/7ecc5feb-1f19-4b09-aed9-9d055aeba92d)

### 3.7.6 배열 첨자는 0부터 시작한다

![CleanShot 2025-02-27 at 01 25 31@2x](https://github.com/user-attachments/assets/450d3abf-82e0-4d7a-a6a1-5a1d29187a91)

- 해당 코드는 배열을 초기화하는 코드
- 다만, 앞의 코드에서 배열 첨자가 0에서 시작한다는 사실을 잊었기 때문에 할당 연산을 n+1번 실행하고, 그결과 arr 배열 뒤 메모리를 i로 덮어쓰게됨 

  ![CleanShot 2025-02-27 at 01 26 56@2x](https://github.com/user-attachments/assets/f795eea9-908a-41bf-a158-02ccd2a280ce)

### 3.7.7 스택 오버 플로우
- 말 그대로 함수 스택이 메모리를 초과하는 경우에 발생하는 문제
- 일반적으로 재귀 함수를 호출했을때 끝이 나지 않거나, 예상을 초과하는 호출이 발생할 경우 생겨날 수 있는 버그
- 이를 이용한 해커 공격도 있음
### 3.7.8 메모리 누수
- GC를 사용하지 않는 언어나 혹은 사용하더라도 참조가 잘못 되어 사용하지 않는 객체를 지속적으로 참조하여 메모리 조금씩 늘어나는 반면에 해제가 이루어지지 않아 결국엔 메모리가 고갈되는 문제

  ![CleanShot 2025-02-27 at 01 13 45@2x](https://github.com/user-attachments/assets/6d8ec9d1-7cd9-4fc1-8d41-5998ab26ff53)

## 3.8 왜 SSD는 메모리로 사용할 수 없을까?
- SSD는 HDD에 비하면 매우 빠른 속도임
- 따라서, SSD를 메모리로도 사용할 수 있을 것 같아보일 수 도 있으나, 대부분 그렇게 사용하지는 않음
- 왜냐하면, SSD가 빠르다 한들 메모리에 비하면 10분의 1 수준의 속도임
- 이 밖에도 여러가지 이유가 있음

### 3.8.1 메모리 읽기/쓰기와 디스크 읽기/쓰기의 차이
- 메모리의 주소 지정 단위는 바이트(Byte)임
 - 즉, 각 바이트마다 메모리 주소가 부여되어 있고, CPU가 이 주소를 이용하여 해당 내용에 직접 접근할 수도 있다는 것을 의미함 

- 반면에, SSD는 조각 단위로 관리되며 이 조각의 크기는 매무 다양함
  - CPU가 파일의 특정 바이트에 직접적으로 접근할 수 없다는 의미

    ![CleanShot 2025-02-27 at 00 38 38@2x](https://github.com/user-attachments/assets/9ebacc56-f6bd-4278-b665-606ddb0e93bb)

- 즉, 서로 다른 포맷으로 관리되기 때문에 메모리를 대체하는 역할이 되기는 어려움

### 3.8.2 가상 메모리의 제한
- 최신 운영 체제의 메모리 관리는 기본적으로 가상 메모리 기반으로 동작함
- 여기서 문제가 발생하는데, 32비트 시스템인 경우 최대 주소 지정 범위가 4GB 밖에 안됨
- 따라서, 1TB가 넘는 SSD를 사용하더라도 여전히 각 프로세스는 4GB 이상의 메모리를 사용할 수는 없음
  - 64비트 시스템인 경우에는 상관 없음 

### 3.8.3 SSD 사용 수명 문제
- SSD의 경우에는 사용 수명 제한이 존재함
- CPU는 프로그램을 실행 할때 대량의 메모리 읽기와 쓰기 작업을 실행하므로 SSD를 메모리로 사용할 경우 사용 수명 때문에 시스템에 병목 현상이 발생할 수 있음
  - SSD 자체가 대량의 읽기/쓰기를 지원하기 위해 만들어지지 않았으며 일반적인 상황에서는 이런 문제를 신경쓰지 않아도 됨 

- 즉, 하드웨어 측면과 소프트 웨어 측면 모두 SSD를 메모리로 사용할 수 있도록 지원하는 상황이 아님
