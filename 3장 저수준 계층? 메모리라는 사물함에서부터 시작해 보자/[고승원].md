# 3장 저수준 계층? 메모리라는 사물함에서부터 시작해 보자

# 3.1 메모리의 본질, 포인터와 참조

## 메모리의 본질은 무엇일까?

- 메모리는 사물함에 비유할 수 있으며, 가장 작은 단위의 기준인 셀이 한 칸이라고 생각하면 된다. (0/1만 보관)
- 사물함마다 번호를 붙이지 않고, 각 바이트마다 번호를 붙인다. 즉 바이트마다 메모리 주소를 가진다. (2^8개)
- 바이트로 표현할 수 있는 숫자는 0~255기 때문에 4개의 바이트로 묶어서 표현한다. (2^32개 = int)
- 정수 외에도 여러 정보 조합을 표현할 땐 12개의 바이트로 묶어서 표현한다. = 객체

## 변수의 의미

- 각 바이트에 순번을 지어줘서 사물함을 찾을 수 있도록 한다. 이걸 메모리 주소라고 한다.
- 1 + 2를 수행하는 순서
    - store $1 6 (1이라는 숫자를 6번 사물함에 넣는다)
    - load r1 6 (6번 사물함에서 값을 읽어 r1레지스터에 로드)
    - 6번 사물함이라는 말이 너무 어려우니 메모리 주소에 변수라는 이름을 부여
- a변수의 값을 b변수에도 복사가 가능하다. (a 주소 값을 가지는게 아니라, 그 주소에 있는 값을 부여)

## 포인터 이해하기

만일 메모리의 절반보다 큰 값을 a, b 변수에 담으려면 어떻게 해야할까

→ 불필요한 복사본을 만들지 않고, 한 변수에 저장한 뒤 그 주소를 다른 변수에 저장한다. 이를 포인터라고 한다.

- 포인터는 메모리 주소를 더 높은 수준으로 추상화 한 것이다.
- 간접지정 (포인터) 수행 순서
    - load r1 @1 (메모리 주소 1의 값을 r1 레지스터에 적재)
    - 따라서 b 변수에 저장된 값을 타고 a 변수에 접근하여 데이터에 접근한다. (b 주소 → a 주소 → 데이터)

## 포인터의 능력과 책임

C언어에선 메모리 주소를 개발자가 직접 알고 제어한다. 이는 저수준 계층을 제어하는 강력한 힘이다.

Java, Python처럼 포인터 개념이 없는 언어에서는 포인터 개념이 없지만, 이를 이해하면 좋다.

포인터가 있는 언어에서는 변수가 모호한 개념이 아니라 실제 메모리 주소를 갖는 뚜렷한 개념이 된다.

포인터는 메모리 주소를 직접 알 수 있다는 강력한 기능과 동시에 포인터 연산이 오류가 났을 때 프로그램을 직접 파괴하기도 한다.

사실 포인터가 어디에 좋은지 모르겠다.

## 포인터에서 참조로 : 메모리 주소 감추기

참조 : 메모리주소를 추상화한 포인터를 한 번 더 추상화 한 개념

- 포인터 처럼 메모리 주소를 알 수 없고, 포인터와 유사한 연산도 할 수 없다.
- 데이터를 복사할 필요 없이 포인터와 동일한 효과를 얻을 수 있다.

# 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

![image](https://github.com/user-attachments/assets/434d7d26-b10b-4514-929a-653c8c8c66b3)

64비트 기준 메모리 내 프로세스 구조

- 코드 영역, 데이터 영역 : 실행 파일 초기화
- 힙 영역 : 동적 메모리 할당
- 스택 영역 : 함수 호출

## 가상 메모리

위의 사진은 가상 메모리이다. 실제 메모리 구조는 다음과 같을 것이다.

![image](https://github.com/user-attachments/assets/f726b1c0-5fba-4c75-a154-511c34f0bf1c)

1. 프로세스는 동일한 크기의 chunk로 나뉘어 물리 메모리에 저장된다.
2. 모든 chunk는 물리 메모리에 무작위로 흩어져 있다.

가상 메모리와 물리 메모리 사이의 mapping만 잘 유지하면 사용하는데 문제가 발생하지 않으니 걱정하지 않아도 된다.

## 페이지와 페이지 테이블

![image](https://github.com/user-attachments/assets/27466fed-0725-4de4-9ad9-e94717468ebd)

위 처럼 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 존재한다.

위 그림에서 Part가 하나의 Page라고 생각하면 된다. page table은 매핑 정보

이와 같은 방법 덕분에 여러 프로세스에서 가상 메모리를 사용할 수 있고, 그 메모리 주소가 같다 하더라도 각 프로세스에 존재하는 페이지 테이블을 사용하여 물리 메모리 주소로 접근할 수 있다.

# 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

함수에서 함수를 호출하고, 리턴값을 받아 진행하는 경우를 스택으로 표현한다.

## 스택 프레임 및 스택 영역

스택 프레임 : 함수 실행 시에 여러 정보가 저장되는 곳. call stack이라고도 한다.

스택 영역 : 스택 프레임이 생성되는 영역.

즉 하나의 트색 영역에 여러 스택 프레임이 쌓인다.

## 함수 점프와 반환

점프 : 어디로 가는지에 대한 정보

반환 : 어디서 왔는지에 대한 정보

함수가 호출될 때 CPU 제어권은 옮겨진다. 제어권이 이전될 때 점프와 반환 정보가 필요하다.

이런 정보는 스택 프레임에 저장된다.

### 함수 호출에 따른 스택 프레임 변화

- CPU가 함수 A의 기계 명령어를 실행할 때 (A의 기계 명령어가 함수 B를 실행하는 상황)

![image](https://github.com/user-attachments/assets/ab7308df-8e84-4c4a-8e99-7446e3c928cb)

- 함수 A의 스택 프레임에 반환 주소가 추가된다. (B를 호출하기 위한 준비 상황)

![image](https://github.com/user-attachments/assets/2b9beb49-4537-4888-b943-e3279099208a)

- B함수가 호출되는 상황 (B함수가 모두 실행되고 ret에 다르면, A의 반환 주소로 점프한다)

![image](https://github.com/user-attachments/assets/04082bcf-e239-406c-99d2-f440104cf016)

## 매개변수와 지역변수

함수 간 점프와 반환을 할 때 값을 어떻게 전달하까?

매개변수는 x86-64 기준으로 모두 레지스터에 저장하고 가져온다. 만일, 레지스터 공간이 부족한 경우 스택 프레임을 사용한다.

전역 변수는 프로세스 주소 공간의 데이터 영역에 적재된다.

지역 변수는 레지스터 또는 스택 프레임에 저장된다.

## 레지스터 저장과 복원

레지스터에 저장된 값을 꺼내어 읽고, 다시 저장할 때 어디에 저장할까?

→ 스택 프레임

## 정리

스택 프레임엔 레지스터 값, 지역 변수, 매개변수, 반환 주소 등이 저장된다.

스택 프레임은 스택 영역 내부에 존재한다.

스택 영억은 프로세스 주소 공간의 일부이다.

![image](https://github.com/user-attachments/assets/045262d7-41fb-49cf-a8bf-54f56fce43c4)

재귀 함수가 끝나지 않는다면, 스택 프레임이 점점 쌓여 stack overlfow 에러가 발생한다.

- 너무 큰 지역 변수를 만들지 말라.
- 함수 호출 단계가 너무 많으면 안된다.

매개변수가 너무 많아 레지스터에 저장되지 못하는 정보를 아는 방법

→ CPU마다 호출 규약이 있어서, gdb, objdump라는 명령어를 사용해 레지스터와 스택 상태를 볼 수 있다.

스택 영역의 증감은 어떻게 구현될까?

- 호출시
    1. 함수 호출시 반환 주소를 스택에 저장 (위에서 설명함)
    2. 매개 변수를 레지스터 or 스택에 저장 (위에서 설명함)
    3. 스택 포인터 감소
    4. 새로운 스택 프레임 생성
    5. 지역 변수 공간 확보

- 반환시
    1. 지역 변수 공간 해제
    2. 스택 포인터 증가
    3. 반환된 주소로 이동 (위에서 설명함 ret명령어 사용)
    4. 매개변수 정리 및 레지스터 상태 복구

스택 영역의 책임은 누구에게 있을까?

- 컴파일러 : 스택 프레임 제어, 레지스터 or 스택에 저장하는 책임
- 링커, OS : 스택 메모리 설정 및 관리
- CPU : 스택 동작 구현
