# 3장 저수준 계층? 메모리라는 사물함에서부터 시작해 보자

# 3.1 메모리의 본질, 포인터와 참조

## 메모리의 본질은 무엇일까?

- 메모리는 사물함에 비유할 수 있으며, 가장 작은 단위의 기준인 셀이 한 칸이라고 생각하면 된다. (0/1만 보관)
- 사물함마다 번호를 붙이지 않고, 각 바이트마다 번호를 붙인다. 즉 바이트마다 메모리 주소를 가진다. (2^8개)
- 바이트로 표현할 수 있는 숫자는 0~255기 때문에 4개의 바이트로 묶어서 표현한다. (2^32개 = int)
- 정수 외에도 여러 정보 조합을 표현할 땐 12개의 바이트로 묶어서 표현한다. = 객체

## 변수의 의미

- 각 바이트에 순번을 지어줘서 사물함을 찾을 수 있도록 한다. 이걸 메모리 주소라고 한다.
- 1 + 2를 수행하는 순서
    - store $1 6 (1이라는 숫자를 6번 사물함에 넣는다)
    - load r1 6 (6번 사물함에서 값을 읽어 r1레지스터에 로드)
    - 6번 사물함이라는 말이 너무 어려우니 메모리 주소에 변수라는 이름을 부여
- a변수의 값을 b변수에도 복사가 가능하다. (a 주소 값을 가지는게 아니라, 그 주소에 있는 값을 부여)

## 포인터 이해하기

만일 메모리의 절반보다 큰 값을 a, b 변수에 담으려면 어떻게 해야할까

→ 불필요한 복사본을 만들지 않고, 한 변수에 저장한 뒤 그 주소를 다른 변수에 저장한다. 이를 포인터라고 한다.

- 포인터는 메모리 주소를 더 높은 수준으로 추상화 한 것이다.
- 간접지정 (포인터) 수행 순서
    - load r1 @1 (메모리 주소 1의 값을 r1 레지스터에 적재)
    - 따라서 b 변수에 저장된 값을 타고 a 변수에 접근하여 데이터에 접근한다. (b 주소 → a 주소 → 데이터)

## 포인터의 능력과 책임

C언어에선 메모리 주소를 개발자가 직접 알고 제어한다. 이는 저수준 계층을 제어하는 강력한 힘이다.

Java, Python처럼 포인터 개념이 없는 언어에서는 포인터 개념이 없지만, 이를 이해하면 좋다.

포인터가 있는 언어에서는 변수가 모호한 개념이 아니라 실제 메모리 주소를 갖는 뚜렷한 개념이 된다.

포인터는 메모리 주소를 직접 알 수 있다는 강력한 기능과 동시에 포인터 연산이 오류가 났을 때 프로그램을 직접 파괴하기도 한다.

사실 포인터가 어디에 좋은지 모르겠다.

## 포인터에서 참조로 : 메모리 주소 감추기

참조 : 메모리주소를 추상화한 포인터를 한 번 더 추상화 한 개념

- 포인터 처럼 메모리 주소를 알 수 없고, 포인터와 유사한 연산도 할 수 없다.
- 데이터를 복사할 필요 없이 포인터와 동일한 효과를 얻을 수 있다.

# 3.2 프로세스는 메모리 안에서 어떤 모습을 하고 있을까?

![image](https://github.com/user-attachments/assets/434d7d26-b10b-4514-929a-653c8c8c66b3)

64비트 기준 메모리 내 프로세스 구조

- 코드 영역, 데이터 영역 : 실행 파일 초기화
- 힙 영역 : 동적 메모리 할당
- 스택 영역 : 함수 호출

## 가상 메모리

위의 사진은 가상 메모리이다. 실제 메모리 구조는 다음과 같을 것이다.

![image](https://github.com/user-attachments/assets/f726b1c0-5fba-4c75-a154-511c34f0bf1c)

1. 프로세스는 동일한 크기의 chunk로 나뉘어 물리 메모리에 저장된다.
2. 모든 chunk는 물리 메모리에 무작위로 흩어져 있다.

가상 메모리와 물리 메모리 사이의 mapping만 잘 유지하면 사용하는데 문제가 발생하지 않으니 걱정하지 않아도 된다.

## 페이지와 페이지 테이블

![image](https://github.com/user-attachments/assets/27466fed-0725-4de4-9ad9-e94717468ebd)

위 처럼 사상 관계를 유지하는 것을 페이지 테이블이라고 하며, 각각의 프로세스에는 단 하나의 페이지 테이블만 존재한다.

위 그림에서 Part가 하나의 Page라고 생각하면 된다. page table은 매핑 정보

이와 같은 방법 덕분에 여러 프로세스에서 가상 메모리를 사용할 수 있고, 그 메모리 주소가 같다 하더라도 각 프로세스에 존재하는 페이지 테이블을 사용하여 물리 메모리 주소로 접근할 수 있다.

# 3.3 스택 영역: 함수 호출은 어떻게 구현될까?

함수에서 함수를 호출하고, 리턴값을 받아 진행하는 경우를 스택으로 표현한다.

## 스택 프레임 및 스택 영역

스택 프레임 : 함수 실행 시에 여러 정보가 저장되는 곳. call stack이라고도 한다.

스택 영역 : 스택 프레임이 생성되는 영역.

즉 하나의 트색 영역에 여러 스택 프레임이 쌓인다.

## 함수 점프와 반환

점프 : 어디로 가는지에 대한 정보

반환 : 어디서 왔는지에 대한 정보

함수가 호출될 때 CPU 제어권은 옮겨진다. 제어권이 이전될 때 점프와 반환 정보가 필요하다.

이런 정보는 스택 프레임에 저장된다.

### 함수 호출에 따른 스택 프레임 변화

- CPU가 함수 A의 기계 명령어를 실행할 때 (A의 기계 명령어가 함수 B를 실행하는 상황)

![image](https://github.com/user-attachments/assets/ab7308df-8e84-4c4a-8e99-7446e3c928cb)

- 함수 A의 스택 프레임에 반환 주소가 추가된다. (B를 호출하기 위한 준비 상황)

![image](https://github.com/user-attachments/assets/2b9beb49-4537-4888-b943-e3279099208a)

- B함수가 호출되는 상황 (B함수가 모두 실행되고 ret에 다르면, A의 반환 주소로 점프한다)

![image](https://github.com/user-attachments/assets/04082bcf-e239-406c-99d2-f440104cf016)

## 매개변수와 지역변수

함수 간 점프와 반환을 할 때 값을 어떻게 전달하까?

매개변수는 x86-64 기준으로 모두 레지스터에 저장하고 가져온다. 만일, 레지스터 공간이 부족한 경우 스택 프레임을 사용한다.

전역 변수는 프로세스 주소 공간의 데이터 영역에 적재된다.

지역 변수는 레지스터 또는 스택 프레임에 저장된다.

## 레지스터 저장과 복원

레지스터에 저장된 값을 꺼내어 읽고, 다시 저장할 때 어디에 저장할까?

→ 스택 프레임

## 정리

스택 프레임엔 레지스터 값, 지역 변수, 매개변수, 반환 주소 등이 저장된다.

스택 프레임은 스택 영역 내부에 존재한다.

스택 영억은 프로세스 주소 공간의 일부이다.

![image](https://github.com/user-attachments/assets/045262d7-41fb-49cf-a8bf-54f56fce43c4)

재귀 함수가 끝나지 않는다면, 스택 프레임이 점점 쌓여 stack overlfow 에러가 발생한다.

- 너무 큰 지역 변수를 만들지 말라.
- 함수 호출 단계가 너무 많으면 안된다.

매개변수가 너무 많아 레지스터에 저장되지 못하는 정보를 아는 방법

→ CPU마다 호출 규약이 있어서, gdb, objdump라는 명령어를 사용해 레지스터와 스택 상태를 볼 수 있다.

스택 영역의 증감은 어떻게 구현될까?

- 호출시
    1. 함수 호출시 반환 주소를 스택에 저장 (위에서 설명함)
    2. 매개 변수를 레지스터 or 스택에 저장 (위에서 설명함)
    3. 스택 포인터 감소
    4. 새로운 스택 프레임 생성
    5. 지역 변수 공간 확보

- 반환시
    1. 지역 변수 공간 해제
    2. 스택 포인터 증가
    3. 반환된 주소로 이동 (위에서 설명함 ret명령어 사용)
    4. 매개변수 정리 및 레지스터 상태 복구

스택 영역의 책임은 누구에게 있을까?

- 컴파일러 : 스택 프레임 제어, 레지스터 or 스택에 저장하는 책임
- 링커, OS : 스택 메모리 설정 및 관리
- CPU : 스택 동작 구현

# 3.4 힙 영역 : 메모리의 동적 할당은 어떻게 구현될까?

함수 호출이 많아지면 스택 영역에 쌓이는 스택 프레임의 크기가 커진다. 반대로 함수 호출이 완료되면, 기존 스택 프레임 정보는 더이상 사용되지 않는다.

주의점

- 따라서 함수 호출이 완료된 후 스택 프레임에 저장되어 있던 내용을 사용하면 안된다.
- 지역 변수의 수명 주기는 함수와 동일하다. 따라서 지역 변수가 사용할 메모리 할당과 반환에 신경쓰지 않아도 된다.

## 힙 영역이 필요한 이유

- 지역 변수의 특성도, 전역 변수의 특성도 갖지 않는 변수를 저장하기 위한 장소
- 함수의 호출 횟수와 관계없이 프로그래머가 해당 메모리 영역의 사용이 완료될 때 까지 유효하게 유지하기 위한 장소. 즉, 프로그래머가 수명 주기를 결정할 수 있는 장소

## malloc 메모리 할당자 직접 구현하기

malloc 메모리 할당자 : C/C++에서 메모리 동적 할당/해제 요청을 하는 프로그램

직접 구현하기 위한 요구사항

- 적절한 크기의 가능한 메모리 영역을 제공한다. 무엇을 저장하는지 신경쓰지 않는다.
- int, float, list 등 구조를 신경쓰지 않고 모든 데이터를 저장한다.
- 메모리 영역의 사용이 완료되었을 때 힙 영역에 이 메모리 영역을 반환한다.

## 여유 메모리 조각 관리하기

1. 연결 리스트 : 연결 리스트와 메모리 사용 정보를 메모리 조각에 함께 저장한다.
    1. 해당 메모리가 비어있는지 알려주는 flag를 기록
    2. 해당 메모리의 크기를 기록한 숫자

위처럼 메모리를 만드는 경우 이렇게 될 것이다. (페이로드)

![image](https://github.com/user-attachments/assets/0352ff52-7e15-4fe2-9eb5-944d561f65ca)

## 메모리 할당 상태 추적하기

![image](https://github.com/user-attachments/assets/d7b1e781-cd0d-499b-8ebe-d60a3efbb62b)

이렇게 되면 모든 메모리 조각은 header 정보를 통해 찾아갈 수 있다.

마지막의 0/1 header는 마지막에 끝을 알려주기 위한 4바이트 공간이다.

## 어떻게 여유 메모리 조각을 선택할 것인가 : 할당 전략

1. **최초 적합 방식** : 가장 먼저 발견된 요구사항을 만족하는 항목 반환
    1. 단순하다.
    2. 앞부분에 작은 메모리 조각이 많이 남는다. (비효율적)
2. **다음 적합 방식** : 최초 적합과 유효하지만, 마지막 검색 지점으로부터 시작한다.
    1. 최초 적합 방식보다 더 빠르게 탐색 한다.
    2. 적합 메모리 사용률이 최초 적합 방식에 미치지 못한다.
3. **최적 적합 방식** : 사용 가능한 메모리 조각을 모두 찾고, 크기가 가장 작은 조각 반환 
    1. 메모리 공간을 더 잘 활용한다.
    2. 위 두가지 방법보다 느리다.

## 메모리 할당하기

사용자가 메모리 조각의 요청할 때 정보를 반환하는 것이 아니라 header의 주소를 반환한다.

32바이트 공간에 12바이트 데이터를 저장 한 경우 16바이트 공간이 내부 단편화 된다 (32 - 4헤더 - 12데이터)

따라서 뒤쪽에 남은 메모리 공간으로 메모리 공간을 만든다.

![image](https://github.com/user-attachments/assets/04143cee-aab9-4fd6-85bf-29e9098f949f)

그림 잘못된듯 16아님 12바이트 사용 가능

## 메모리 해제하기

1. header에 접근하여 해제 여부를 기록한다.
2. 인접한 메모리 조각이 비어있을 때 더 큰 메모리 조각으로 서로 병합한다. (부하가 있지만, 간단해서 사용)

## 여유 메모리 조각을 효율적으로 병합하기

![image](https://github.com/user-attachments/assets/dcf1b379-ea0b-4e3a-bf99-8ec04ad75247)

중간에 데이터가 비어있지 않아서 병합할 수 없다.

메모리 조각 끝에 꼬리 정보를 추가한다.

![image](https://github.com/user-attachments/assets/2c7a488b-d5a3-410d-9be5-5504d8d81c85)

이렇게 되면 메모리 조각은 양방향 리스트가 된다. 즉, 중간 데이터를 건너 뛰고 메모리 조각을 병합할 수 있다.

# 3.5 메모리를 할당할 때 저수준 계층에서 일어나는 일

## CPU 실행 상태

CPU는 실행하는 코드의 중요도에 따라 네 가지 특권 단계(Privilege Level) 를 가진다.

- **특권 0 (커널 모드, Ring 0)** : 운영체제(OS) 핵심 코드 실행, 모든 하드웨어 접근 가능
- **특권 3 (사용자 모드, Ring 3)** : 일반 응용 프로그램 실행, OS 보호를 위해 제한된 권한

운영체제는 보안과 안정성을 위해 일반 프로그램을 사용자 모드에서 실행하며, 시스템 호출(System Call)을 통해 필요한 작업을 요청하게 된다.

## **커널 상태와 사용자 상태**

**커널 모드(Kernel Mode)**

- 운영체제가 실행되는 상태
- 모든 하드웨어 자원 및 메모리에 접근 가능
- 예) 파일 시스템 접근, 메모리 할당, 프로세스 관리 등

**사용자 모드(User Mode)**

- 일반 프로그램이 실행되는 상태
- 특정 주소 영역(운영체제 영역) 접근 불가
- 예) `printf()`, `malloc()` 등

**Segmentation Fault 발생**

사용자 모드에서 커널 모드의 영역(운영체제 메모리)을 직접 접근하려 하면 Segmentation Fault 오류 발생.

이를 방지하기 위해 CPU는 보호 모드를 지원하며, 사용자는 시스템 호출을 통해 간접적으로 운영체제 기능을 사용함.

## **시스템 호출(System Call)**

운영체제의 기능을 사용하기 위해 제공되는 인터페이스.

- 응용 프로그램은 직접 OS에 접근할 수 없으므로 시스템 호출을 통해 요청
- 시스템 호출을 실행하면 CPU 모드가 사용자 모드 → 커널 모드로 변경
- 예) 파일 읽기/쓰기, 네트워크 통신, 메모리 할당 등

### **시스템 호출의 흐름 (ex INT)**

1. 응용 프로그램이 시스템 호출(`syscall`) 실행
2. CPU가 사용자 모드 → 커널 모드로 전환
3. 운영체제가 요청 처리 후 결과 반환
4. CPU가 커널 모드 → 사용자 모드로 전환 후 프로그램 실행 지속
- 실제로 C에서 `printf()` 실행 시 표준 라이브러리를 거쳐 `write()` 시스템 호출

## 표준 라이브러리

OS마다 시스템 호출이 다르다. 따라서 우리는 추상화된 표준이 필요하다.

C에선 이 일을 표준 라이브러리가 한다.

![image](https://github.com/user-attachments/assets/eccb35fd-8f72-43ad-888c-11c80d8c27cb)

응용 프로그램은 일반적으로 표준 라이브러리만 의사소통 대상으로 간주해서 여러 OS에서 같은 동작을 할 수 있다.

3.4에서 다뤘던 malloc같은 메모리 할당자도 표준 라이브러리의 일부이다.

## **힙 영역의 메모리가 부족할 때**

**힙영역 할당 과정**

- 내부적으로 힙(Heap) 영역에서 메모리를 할당
- 힙 영역에 사용 가능한 메모리 블록이 없으면, 운영체제에 추가 메모리를 요청
- 힙 메모리 확장 방법
    1. `brk()` 시스템 호출: 힙 영역의 끝(브레이크 포인트)을 확장 (유휴공간)
    2. `mmap()` 시스템 호출: 특정 크기의 메모리 매핑

**힙 영역 확장 과정**

1. `malloc()` 실행
2. 내부적으로 힙 영역에서 여유 블록을 찾음
3. 여유 블록이 없으면 OS에 메모리 요청 (`brk()` or `mmap()`)
4. 운영체제가 가상 메모리 공간을 확장
5. 확장된 메모리를 `malloc()`이 사용

**메모리 풀 (Memory Pool) 기법**

반복적인 `malloc()` 호출은 성능 저하를 초래할 수 있음 → 메모리 풀을 사용하여 미리 할당된 메모리를 재사용하여 성능 최적화 가능.

## **가상 메모리와 물리 메모리**

### **가상 메모리란?**

- 운영체제가 프로세스에 제공하는 논리적인 메모리 주소 공간
- 실제 물리 메모리가 아니라, 운영체제가 관리하는 페이지 테이블을 통해 물리 메모리에 매핑됨
- 가상 메모리가 물리 메모리에 연결되어 있지 않으면 page fault 발생

**페이지 폴트(Page Fault)란?**

- 프로그램이 아직 물리 메모리에 할당되지 않은 가상 메모리를 접근하려 할 때 발생
- 운영체제가 새로운 물리 메모리 페이지를 할당하고 페이지 테이블을 갱신함
- 이후 프로그램이 정상적으로 해당 메모리를 사용 가능

## **메모리 할당 과정 정리**

1. `malloc()` 호출
2. 여유 블록 검색 후 할당
3. 여유 블록이 없으면 `brk()` 또는 `mmap()` 호출 → 커널 모드 진입
4. 운영체제가 가상 메모리 확장 후 `malloc()`에 반환
5. 프로그램이 해당 메모리에 접근하면 페이지 폴트 발생
6. 운영체제가 실제 물리 메모리를 할당 후 페이지 테이블 갱신
7. 프로그램이 정상적으로 메모리 사용 가능

## 결론

- `malloc()`이 반환하는 메모리는 실제 물리 메모리가 아닌 가상 메모리
- 실제 물리 메모리는 프로그램이 메모리를 실제로 사용할 때 할당됨 (page fault)
- 운영체제의 메모리 관리 방식을 이해하면, 성능 최적화를 위한 전략(`Memory Pool`, `mmap()` 활용 등)을 수립할 수 있음

# **3.6 고성능 서버의 메모리 풀은 어떻게 구현될까?**

## **메모리 풀 vs 범용 메모리 할당자**

**범용 메모리 할당자 (`malloc()`)**

- 운영체제(OS)가 직접 관리하는 메모리 할당 방식
- 다양한 상황에서 사용 가능하지만, 할당/해제 비용이 큼
- 힙 영역을 동적으로 확장해야 할 수도 있어 성능 저하 발생 가능

**메모리 풀 (Memory Pool)**

- 특정한 목적에 맞춰 최적화된 메모리 관리 기법
- 미리 큰 메모리 블록을 할당한 후, 필요한 만큼만 분배하여 사용
- 운영체제의 개입 없이 빠르게 메모리 할당 가능

비교 정리

| 구분 | 범용 메모리 할당자 (`malloc()`) | 메모리 풀 |
| --- | --- | --- |
| **관리 주체** | OS | 응용 프로그램 |
| **속도** | 상대적으로 느림 (OS 개입) | 빠름 (OS 개입 없음) |
| **사용성** | 범용적으로 사용 가능 | 특정 환경에 맞춰 최적화 |
| **성능 최적화** | 별도 최적화 필요 | 메모리 할당/해제 비용 최소화 가능 |

메모리 풀이 활용되는 경우

- 대량의 객체 생성/해제가 빈번한 경우
- 실시간 시스템, 고성능 서버 등

## 메모리 풀의 동작 원리

- `malloc()`을 호출하는 대신 미리 큰 메모리 조각을 할당해두고 필요할 때마다 재사용
- 표준 라이브러리 및 운영체제 개입 없이 동작

메모리 할당 방식 차이

1. 범용 메모리 할당 (`malloc()`)
    
    ```
    프로그램 → 표준 라이브러리 → 운영체제 → 메모리 할당
    ```
    
2. 메모리 풀
    
    ```
    프로그램 → 메모리 풀 → 미리 할당된 블록에서 메모리 제공
    ```
    

## 약간 복잡한 메모리 풀 구현하기

메모리 조각을 연결 리스트로 연결하고 포인터를 사용한다.

![image](https://github.com/user-attachments/assets/406819d4-2afd-427f-8354-5b730ad40238)

**메모리 풀 최적화 전략**

- 블록 관리 : 작은 블록과 큰 블록을 별도로 관리하여 효율적인 메모리 활용 가능
- 메모리 크기 증가 : 새로운 블록을 할당할 때, 기존 블록 크기의 **2배 크기**로 확장하여 재할당
- 스레드별 관리 : 스레드마다 별도의 메모리 풀을 유지하여 동시 접근 충돌 방지

## 메모리 풀의 스레드 안전 문제

멀티스레드 환경에서는 여러 스레드가 동시에 메모리 풀을 사용하면 경쟁 조건(Race Condition) 이 발생할 수 있음.

→ 스레드별 전용 메모리 풀로 문제 해결

**스레드별 메모리 풀 관리 방법**

- 각 스레드가 독립적인 메모리 풀을 가짐
- 스레드 간 공유 없음 → 락(lock) 없이 동작 가능
- 특정 스레드에서만 사용되므로 성능 최적화 가능

만약 한 스레드에서 할당한 메모리를 다른 스레드가 해제해야 한다면?

- Shared Pool : 모든 스레드가 접근 가능
- Deferred Free List : 메모리를 특정 시점까지 보관했다가 일괄 해제

## 결론

- 범용 메모리 할당(`malloc()`)과 메모리 풀은 각각 장단점이 있음
- 메모리 풀은 특정 환경에서 성능을 최적화하는 데 유용
- 멀티스레드 환경에서는 스레드별 풀을 관리하여 동기화 비용을 줄일 수 있음

### 추가

GC와 메모리 풀의 차이

1. GC는 자동으로 메모리 관리 및 해제
2. 메모리 풀은 개발자가 직접 관리

# **3.7 대표적인 메모리 관련 버그**(겪을 일이 있을까?)

### 1. 지역 변수의 포인터 반환

```c
int* func() {
    int a = 2;
    return &a; // 덮어 씌워질 위험
    -----------------------------------
    int a = 2;
    *a = 2;
    return a; // 힙 영역에 메모리 할당 후 반환
}
```

**문제점**

- 지역 변수 `a`는 `func()`의 스택 프레임에 저장됨
- `func()`가 실행을 마치면 스택 프레임이 제거 되므로, 반환된 포인터가 가리키는 메모리는 유효하지 않음
- 다른 함수가 호출되면 덮어 씌워질 가능성이 높음

**해결 방법**

- 지역 변수를 반환하는 대신, 힙 영역에 메모리를 할당하고 반환

### 2. 포인터 연산 실수

```c
int sum(int* arr, int len) {
    int sum = 0;
    for (int i = 0; i < len; i++) {
        sum += *arr;
        arr += sizeof(int);  // 잘못된 연산
    }
    return sum;
}
```

**문제점**

- `arr += sizeof(int);`는 잘못된 포인터 연산
- 포인터를 1 증가시키면 자동으로 `sizeof(int)`만큼 이동하므로 `sizeof(int)`를 추가하면 4배 더 이동하게 됨

**해결 방법**

- `arr++`으로 수정하여 정상적인 메모리 이동 수행

### 3. 문제 있는 포인터 역참조

```c
int a;
scanf("%d", a);  // 잘못된 코드
-----------------------------------
scanf("%d", &a); // 변수 주소 전달
```

**문제점**

- `scanf()`는 주소를 요구하지만, 변수 자체를 전달함
- `scanf()`가 `a`의 값을 메모리 주소로 해석하고, 예기치 않은 메모리 위치에 값을 저장하려 시도
- 잘못된 주소를 참조하면 프로세스가 강제 종료되거나, 예측 불가능한 동작 발생

**해결 방법**

- 변수의 주소를 전달해야 함

### 4. 초기화되지 않은 메모리 읽기

```c
void add() {
    int* a = (int*)malloc(sizeof(int));
    *a += 10;  // 초기화되지 않은 메모리 사용
    -----------------------------------
    int* a = (int*)malloc(sizeof(int));
		*a = 0;    // 할당 직후 명시적으로 초기화
		
		int* a = (int*)calloc(1, sizeof(int)); // calloc 사용
}
```

**문제점**

- `malloc()`이 할당한 메모리는 기본적으로 초기화되지 않음
- 초기화되지 않은 값이 포함될 수 있어 예측 불가능한 결과 발생

**해결 방법**

- 할당 직후 명시적으로 초기화
- 또는 `calloc()` 사용 (자동 0 초기화)

### 5. 이미 해제된 메모리 참조

```c
void add() {
    int* a = (int*)malloc(sizeof(int));
    free(a);
    int b = *a;  // 해제된 메모리 접근
    -----------------------------------
    free(a);
		a = NULL;  // NULL 처리
		
		if (a != NULL) {
    int b = *a;
		} // NULL 체크
}
```

**문제점**

- `free(a);` 이후 `a`는 더 이상 유효한 메모리를 가리키지 않음
- 이후 `a`를 참조하면 예측할 수 없는 결과 발생
- 다른 스레드가 같은 메모리를 할당받아 값을 변경할 가능성도 있음

**해결 방법**

- `free()` 이후 포인터를 `NULL`로 설정
- 이후 NULL 체크 후 사용

### 6. 배열 인덱스 초과

```c
void init(int n) {
    int* arr = (int*)malloc(n * sizeof(int));
    for (int i = 0; i <= n; i++) {  // 잘못된 루프 조건
        arr[i] = 1;
    }
    ----------------------------------- 
    for (int i = 0; i < n; i++) {  // 바보같은 휴먼에러 제거
    arr[i] = 1;
		}
}
```

**문제점**

- 배열 인덱스는 `0 ~ n-1` 범위를 가져야 하지만, `<= n`을 사용하여 배열 범위를 초과
- 힙 영역의 다른 데이터를 덮어씌울 가능성 존재

**해결 방법**

- `for` 루프 범위를 `i < n`으로 수정

### 7. 스택 오버플로우 (버퍼 오버플로우)

```c
void buffer_overflow() {
    char buf[32];
    gets(buf);  // 버퍼 크기 초과 가능
    -----------------------------------
    fgets(buf, sizeof(buf), stdin); // 버퍼 크기 제한
}
```

**문제점**

- `gets()`는 입력 길이를 제한하지 않기 때문에, 32바이트를 초과하는 입력을 받으면 스택 프레임을 덮어쓸 위험
- 해커가 이를 이용하면 악성 코드 실행 가능

**해결 방법**

- `gets()` 대신 입력 크기를 제한하는 `fgets()` 사용

### 8. 메모리 누수 (Memory Leak)

```c
void memory_leak() {
    int* p = (int*)malloc(sizeof(int));
    -----------------------------------
    free(p); // 사용 후 메모리 할당 해제
}
```

**문제점**

- `malloc()`을 호출했지만, `free()` 없이 함수가 종료됨
- 프로그램이 종료되기 전까지 메모리가 해제되지 않음 → 메모리 누수 발생
- 지속적으로 발생하면 운영체제가 강제 종료할 수도 있음

**해결 방법**

- 사용이 끝나면 반드시 `free()` 호출

## 결론

1. 메모리 관련 버그는 프로그램의 안정성을 해칠 수 있음
2. 포인터 사용 시 메모리의 유효성을 항상 검증해야 함
3. 메모리 누수를 방지하려면 `malloc()`과 `free()`를 올바르게 관리해야 함

# **3.8 SSD를 메모리로 사용할 수 없는 이유**

## **SSD의 속도와 메모리의 속도 차이**

**SSD와 메모리 속도 비교**

- 최신 SSD의 순차 읽기 속도: 약 7.5GB/s
- DDR5 메모리의 대역폭: 약 60GB/s 이상
- SSD는 RAM보다 약 10배 이상 느림 → 메모리로 사용하면 컴퓨터 성능이 크게 저하됨

**속도 차이의 영향**

- 메모리는 CPU가 명령을 실행할 때 즉각적인 접근이 가능해야 함
- SSD를 메모리로 사용하면 메모리 접근 속도가 느려져 CPU 성능이 제한됨

## 2. 메모리와 디스크의 구조적 차이

**메모리는 바이트 단위, SSD는 블록 단위로 동작**

- 메모리(RAM): 1바이트 단위로 접근 가능
- SSD(디스크): 블록 단위(4KB~16KB)로 데이터 관리
- CPU가 메모리의 특정 바이트에 직접 접근할 수 있지만, SSD는 특정 바이트를 수정하려면 블록 전체를 다시 기록해야 함

**결론**

- CPU는 SSD에서 직접 데이터를 읽거나 실행할 수 없음
- SSD의 블록 단위 접근 방식은 메모리 대체에 부적합

## 3. 가상 메모리의 한계

**32비트 시스템의 메모리 제한**

- 32비트 시스템의 최대 메모리 주소 공간: 4GB
- SSD를 메모리로 사용하더라도 운영체제는 4GB 이상을 사용할 수 없음
- 64비트 시스템에서는 이론적으로 16EB까지 확장 가능하지만, 운영체제의 메모리 관리 구조로 인해 SSD를 직접 메모리로 활용할 수 없음

**결론**

- 운영체제의 메모리 관리 방식은 RAM 기반으로 설계
- SSD를 RAM처럼 사용하려면 운영체제와 하드웨어 변경이 필요

## 4. SSD의 사용 수명 문제

**SSD는 수명이 제한됨**

- SSD는 데이터를 기록할 때마다 내구성이 감소
- SSD의 TBW(Terabytes Written): 일정한 TB 이상의 데이터가 기록되면 성능이 저하되고, 결국 사용이 불가능해짐

**비교 표**

|  | **RAM** | **SSD** |
| --- | --- | --- |
| **데이터 읽기/쓰기 수명** | 무제한 | 기록 횟수 제한 있음 |
| **사용 방식** | 지속적인 데이터 읽기/쓰기 가능 | 일정량의 기록 후 성능 저하 |
| **운영 방식** | 휘발성(전원이 꺼지면 데이터 소멸) | 비휘발성(데이터 유지) |

**결론**

- SSD를 메모리로 사용하면 빠르게 수명이 닳아버림
- SSD는 CPU의 빠른 연산을 지원하기에는 적절하지 않음

## 5. 결론

1. SSD는 RAM보다 속도가 10배 이상 느려 메모리 대체가 불가능함
2. RAM은 바이트 단위 접근이 가능하지만, SSD는 블록 단위로 동작하여 비효율적임
3. 운영체제의 메모리 관리 방식이 SSD를 메모리처럼 활용할 수 있도록 설계되지 않음
4. SSD는 기록 횟수 제한으로 인해 지속적인 메모리 사용에 적합하지 않음
