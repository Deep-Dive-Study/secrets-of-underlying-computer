# ch6 입출력이 없는 컴퓨터가 있을까?
- 인간과 컴퓨터의 상호 작용하는 방식은 시대에 따라 변화하고, 새로운 산업의 형태로 이어지고 있음
  - 컴퓨터, 모바일, 태블릿, VR 기기, 등
  - 여기서 `상호 작용은 컴퓨팅 장치의 입력과 출력을 의미`함

## 6.1 CPU는 어떻게 입출력 작업을 처리할까?
- CPU 내부에 레지스터가 있는 것처럼, 장치에도 자체적인 레지스터인 **`장치 레지스터(device register)`** 가 있음
  - `데이터를 저장하는 레지스터`
    - 사용자가 키보드의 키를 누르면 해당 정보가 해당 레지스터에 저장됨 
  - `제어 정보와 상태 정보를 저장하는 레지스터`
    - 해당 레지스터를 읽고 쓰는 작업을 이용하여 장치를 제어하거나 장치 상태를 볼 수 있음

- CPU에는 전문적으로 장치 레지스터를 읽고 쓰는 특정한 기계 명령어가 존재함
  - ex) x86의 IN/OUT 기계 명령어
  - 장치 마다 고유한 주소가 부여되며, 입출력 명령어에 장치 주소를 지정
- 이외에 메모리 사상 입출력을 통해서도 메모리를 읽고 쓰듯이 장치를 제어할 수 있음 

- 장치의 입출력 처리 방식
  - 폴링 : 순환하면서 계속 검사하기
  - 입터럽트 구동식 : 이벤트가 들어왔을때 멈춰서 반응하기(비동기식)

## 6.2 디스크가 입출력을 처리할 때 CPU가 하는 일은 무엇일까?
- 디스크가 입출력 요청을 처리하는 동안 운영 체제는 CPU가 다른 작업을 수행하도록 스케줄링을 수행함

  ![CleanShot 2025-03-23 at 22 10 04@2x](https://github.com/user-attachments/assets/6a2a3e4c-35ca-4621-ab44-45f56f015ce2)

- 입출력 장치는 대체로 두부분으로 나뉘어짐
  - `장치 드라이버(driver)`
    - 운영 체제에서 장치를 제어하기 위한 코드 
  - `장치 제어기(controller)`
    - 장치 드라이버에서 명령을 받아 외부 장치를 제어하는 하드웨어

  ![CleanShot 2025-03-23 at 22 10 53@2x](https://github.com/user-attachments/assets/6be3d201-8b25-455a-93df-6ef09f0ff9af)

- CPU 입장에서는 데이터를 직접 복사하는 것은 리소스를 낭비하는 행위
- 따라서, CPU 개입 없이 직접 장치와 메모리 사이에 데이터를 전송할 수 있는 작동 방식이 나옴. 이를 DMA(direct memory access) 라고 함

  ![CleanShot 2025-03-23 at 22 14 03@2x](https://github.com/user-attachments/assets/893b96d0-43b0-44ca-8165-e573d051dece)

  - CPU가 어떻게 데이터를 복사할지 알려주는 명령어를 DMA에 전달해야 작업을 수행할 수 있음
 
- 다만, DMA가 메모리에서 읽은 데이터는 CPU에서 메모리까지 반드시 동기화된 최신 데이터는 아닐 수 있음

  ![CleanShot 2025-03-23 at 22 16 11@2x](https://github.com/user-attachments/assets/ee06b240-03e5-48e2-bffa-c5ea4a1cdc27)

- DMA가 데이터 전송을 완료하면 인터럽트 작동 방식을 통해 CPU에게 데이터 전송이 완료되었음을 알려줌

## 6.3 파일을 읽을 때 프로그램에는 어떤 일이 발생할까?
- 메모리 관점에서 입출력
  - 데이터가 외부 장치에서 메모리로 복사되면 입력(input)
  - 데이터가 메모리 사이에서 외부 장치로 복사되면 출력(output) 

    ![CleanShot 2025-03-23 at 22 19 15@2x](https://github.com/user-attachments/assets/66930639-3f24-4697-9dde-638d59618140)

- 프로세스의 파일 읽기
  - 프로세스가 파일 읽기 함수(read)를 호출하면 프로세스는 일시 중지되며, 일출력 블로킹 대기열에 배치됨

    ![CleanShot 2025-03-23 at 22 21 44@2x](https://github.com/user-attachments/assets/b0aebde6-dde8-4ee3-9254-988c67d73820)

  - 운영체제는 DMA를 통해 디스크 데이터를 메모리에 기록함 

    ![CleanShot 2025-03-23 at 22 21 57@2x](https://github.com/user-attachments/assets/ca79facc-67fe-4de4-bcfb-a62d56e61cbd)

  - 읽기가 완료되면 준비 완료 대기열로 이동하고 실행을 기다림
    - 이과정에서 다른 프로세스는 중지되지 않고 실행됨 

    ![CleanShot 2025-03-23 at 22 22 36@2x](https://github.com/user-attachments/assets/d0f154f8-064a-4f67-ae5a-1d4c5a1689f6)

  - 프로세스는 이과정이 매무 빠르면, 중지되었다는 사실도 모름

- 일반적으로 입출력 데이터는 먼저 운영 체제 내부로 복사되며 이후 운영 체제가 프로세스의 주소 공간으로 복사함
  - 직접 복사하는 것을 무복사(zero-copy) 기법이라고 함 

## 6.4 높은 동시성의 비결: 입출력 다중화
- I/O 작업은 결국 파일로 추상화됨
  - 리눅스의 `모든 것은 파일이다(everything is file)` 개념 

- 리눅스에서 파일을 사용하려면, 번호를 하나 할당 받아야함. 이것을 **`파일 서술자(File Descriptor)`** 라고 함 

  ![CleanShot 2025-03-23 at 22 35 01@2x](https://github.com/user-attachments/assets/7d3651fb-d625-4e28-9033-80d3a3b075aa)

- 높은 동시성 처리를 위해서 입출력을 여러개를 받는 방식
  - 파일 서술자를 여러개 만들어서 입력 대기
    - 하나를 처리하는 동안 블록킹됨
    - 다중 스레드로 처리하더라도 최적화된 방향은 아님 

  - **`입출력 다중화(I/O multiplexing)`**
    - 이벤트 루프 방식으로 최적화된 입출력 방식
      - 파일 서술자를 획득
      - 파일 서술자를 감시하다가 읽기, 쓰기 요청이 있을때 반환
      - 반환된 파일 서술자를 통해 요청 처리

- 리눅스의 대표적인 입출력 다중화 기술 3가지
  - select
    - 1024개 파일 제한
    - 프로세스가 깨어났을때, 어떤 파일 서술자가 준비 완료 상태인지 알기위해 전부 확인해야하는 단점 
  - poll
    - 1024개 제한은 없으나, select와 동일한 문제가 있음 
  - **`epoll`**
    - select,poll의 단점을 해결함
    - 커널에 필요한 데이터 구조를 생성하여 준비 완료된 시점에 준비 완료된 파일 서술자를 준비 완료 목록에 추가함

## 6.5 mmap: 메모리 읽기와 쓰기 방식으로 파일 처리하기
- 프로그래머에게는 파일을 읽고 쓰는 것보다 메모리에 읽고 쓰는게 더 편리함
- 다만, 파일을 읽고 쓰는것과 메모리에서 데이터를 읽고 쓰느 것은 근본적으로 차이가 있음
  - 디스크에서 특정 주소를 지정하는 방법이 다름
  - 속도의 차이 

    ![CleanShot 2025-03-23 at 22 46 34@2x](https://github.com/user-attachments/assets/4e278999-c193-445e-80bd-20b97a2f346f)

- 디스크 또한 메모리 처럼 추상화된 형태로 제공되어져 있음
- 이를 활용하여 프로세스 주소 공간과 디스크 공간을 매핑하여 사용할 수 있음

  ![CleanShot 2025-03-23 at 22 47 29@2x](https://github.com/user-attachments/assets/dcfe749f-b480-4c90-9882-e0132a3458bc)

- 이것을 가능하게 하는 것이 운영체제와 mmap이라는 기술임
  - 특정 주소를 읽기를 요청
  - 요청에 데이터가 없는 경우 Page Fault가 발생(인터럽트)
  - CPU는 인터럽트를 처리
    - 실제 디스크 입출력 요청 

  ![CleanShot 2025-03-23 at 22 49 20@2x](https://github.com/user-attachments/assets/c9471107-4172-4477-b0aa-c82af43a8b9c) 

  - 메모리와 디스크 사이에 데이터를 매핑하고 읽고 쓰는 과정은 운영체제에서 수행함 

- 장점
  - 메모리를 사용하듯이 사용할 수 있기 때문에 편리하고 쉬움
  - 성능 상의 이점(반드시 그런것은 아님)
    - 큰 파일 처리시에도 이점이 있음  

- mmap 기술을 통해 동적 링크 라이브러리를 각 프로세스의 주소 공간에 사상하여 최적화함

  ![CleanShot 2025-03-23 at 22 53 36@2x](https://github.com/user-attachments/assets/d9e8b031-4231-4a66-8cc9-30224e9db0df)

## 6.6 컴퓨터 시스템의 각 부분에서 얼만큼 지연이 일어날까?
- 제프 딘이 2012년에 공개한 각 컴퓨터의 여러 가지 작업에 대한 지연 시간 정보
    
  ![CleanShot 2025-03-23 at 22 25 36@2x](https://github.com/user-attachments/assets/88d7d26c-e0cf-4c0d-8a7d-788f15957f05)

- 절대 값은 시긴이 흘러가면서 많이 변화되어지만, 상대적인 속도의 차이는 현재에도 유효함
- CPU와 디스크 간의 차이는 정말 엄청난 차이임
  - CPU 작업이 대략 1초일때 디스크 데이터를 읽는 작업은 1년 정도 걸림 
  
    ![CleanShot 2025-03-23 at 22 28 57@2x](https://github.com/user-attachments/assets/0def65ab-b363-4c27-83ac-293c303d81cb)
