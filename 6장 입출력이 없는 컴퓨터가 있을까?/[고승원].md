# 6.1 CPU는 어떻게 입출력 작업을 처리할까?

마우스와 키보드 같은 외부 장치에도 레지스터가 존재한다.

이 레지스터는 CPU에 존재하는 레지스터와 다르게 두 가지 레지스터로 나뉜다.

1. 데이터를 저장하는 레지스터 : 사용자가 키보드를 누른 정보
2. 제어 정보와 상태 정보를 저장하는 레지스터 : 장치 제어, 상태 확인

### 입출력 기계 명령어

IN : CPU 입력 명령어

OUT : CPU 출력 명령어

메모리도 외부 장치일텐데 LOAD, STORE처럼 쉽게 입출력이 가능하지 않을까?

→ 메모리는 실제 메모리 공간과 주소 공간으로 나뉘는데, 메모리 공간 앞의 4비트로 이를 구분한다.

이를 메모리 사상 입출력이라고 한다.

### CPU가 키보드를 읽고 쓰는 것의 본질

CPU 클럭이 2GHz라면 한 클럭에 0.5ns가 소요된다. (1s = 1,000,000,000ns)

= 한 클럭에 한 기계명령어 실행

1. 폴링 : 계속 검사하기
    
    입력이 생길 때 까지 반복하며 수신 대기
    
    - 불필요한 CPU 사용 (동기)
2. 인터럽트
    1. 인터럽트 신호 감지
    2. 실행중인 컨텍스트 저장
    3. 인터럽트 처리
    4. b에서 저장한 내용 재개
    - 컨텍스트 저장, 재개시 CPU 사용량 많음
    - 비동기 방식

### 인터럽트 처리와 함수 호출의 차이

일반 함수 호출에 필요한 정보

- 반환 주소
- 범용 레지스터의 값
- 매개변수 등

인터럽트 처리에 필요한 정보 일반 함수와 다르게 여러 실행 흐름을 포함해서 훨씬 복잡하고 더 많다

![image](https://github.com/user-attachments/assets/89865c01-0bd5-452f-a9b9-daf0ffad31a1)

실행 처리 순서

1. A 실행
2. A저장 후 B 인터럽트
3. B저장 후 C 인터럽트
4. C저장 후 D 처리
5. C복구 후 처리
6. B복구 후 처리
7. A복구 후 처리

*** 저장할 땐 기계명령어 + 프로그램의 상태를 저장한다

# 6.2 디스크가 입출력 처리할 때 CPU가 하는 일은 무엇일까?

최신 컴퓨터에서는 디스크가 입출력 요청을 처리할 때 CPU 개입이 거의 필요 없음.

CPU는 입출력 요청을 보낸 후 다른 작업을 수행하며, 디스크가 입출력을 완료하면 CPU에 알림.

CPU와 디스크는 서로 독립적으로 작업을 수행하며, 병행 처리가 가능함.

즉 디스크 IO와 CPU 작업은 의존하지 않는다.

### 장치 제어기

![image](https://github.com/user-attachments/assets/f158c06d-5ccc-4379-99c4-87d2e89b3eb7)

- 입출력 장치는 기계 부분과 전자 부분(장치 제어기)으로 나뉨.
- 장치 제어기는 자체 프로세서와 펌웨어를 포함하며, CPU 도움 없이도 작업을 처리할 수 있음.
- 장치 제어기 (드라이버와 다름)
    1. 입출력 장치 제어 및 데이터 버퍼링
    2. CPU와 장치 간의 데이터 전달
    3. 입출력 장치의 동작 상태 관리
- 디스크에서 데이터를 읽고 CPU에게 데이터 전송을 시키지 않고, direct memory access라는 방법을 사용한다.

### 직접 메모리 접근 (direct memory access)

- CPU가 데이터를 직접 복사하는 것은 비효율적이므로, DMA가 CPU 개입 없이 메모리와 장치 간 데이터를 전송.
- DMA 동작 과정:
    1. CPU가 DMA에 데이터 전송 명령을 전달.
    2. DMA가 버스 사용 권한을 요청하고 데이터 전송 시작.
    3. CPU 개입 없이 장치와 메모리 간 데이터 복사.
    4. 데이터 전송 완료 후 인터럽트로 CPU에 알림.

단점

- DMA는 메모리에 데이터를 저장하지만, CPU의 캐시와 메모리 데이터가 다를 수 있음.
    
    → DMA가 데이터를 메모리에 저장할 때 캐시를 갱신하여 데이터 일관성을 유지해야 함.
    

### 6.2.5 입출력과 CPU 리소스 활용

- 운영체제는 CPU가 디스크 입출력 작업을 기다리는 동안 다른 스레드를 실행하도록 스케줄링.
- 입출력은 비동기적으로 실행되며, CPU와 장치는 독립적으로 동작해야 자원을 효율적으로 활용할 수 있음.
- DMA, 인터럽트, 스케줄링 등의 조합으로 CPU 리소스를 최적화.

### 프로그래머에세 시사하는 것

1. CPU는 디스크 입출력에 직접 개입하지 않으며, 병행 처리를 통해 리소스를 최적 활용.
2. 장치 제어기가 발전하여 CPU 없이도 독립적으로 작업 수행.
3. DMA를 활용하면 CPU 개입 없이 메모리와 장치 간 데이터 전송 가능.
4. 캐시 일관성 문제 해결이 필요하며, 운영체제는 CPU와 입출력 장치를 최적으로 스케줄링.

# 6.3 파일을 읽을 때 프로그램에는 어떤 일이 발생할까?

### 메모리 관점에서 입출력

입출력(I/O)은 단순한 데이터 복사 과정이다.

- 입력(Input): 외부 장치 → 메모리
- 출력(Output): 메모리 → 외부 장치

메모리와 외부 장치 간의 데이터 이동이 곧 입출력이며, I/O의 핵심 개념이다.

### `read()` 함수는 어떻게 파일을 읽을까?

1. 프로세스가 `read()` 함수를 호출하면, 운영체제가 디스크에 데이터 요청을 보냄.
2. 디스크는 DMA를 이용해 데이터를 특정 메모리 영역(버퍼)에 복사.
3. 디스크 입출력 속도가 느려서, 프로세스는 I/O가 끝날 때까지 블로킹됨.
4. 운영체제는 CPU가 놀지 않도록, 블로킹된 프로세스 대신 다른 프로세스를 실행.
5. 디스크가 데이터 복사를 완료하면, 인터럽트를 발생시켜 CPU에 알림.
6. CPU는 인터럽트를 처리한 후 블로킹됐던 프로세스를 다시 실행.

![image](https://github.com/user-attachments/assets/ddb6f30b-9f45-41d6-bc56-cdf579096ae3)

### 운영체제의 프로세스 스케줄링

- 입출력 블로킹 대기열과 준비 완료 대기열이 존재.
    - 입출력 블로킹 대기열: 입출력 작업이 끝날 때까지 기다리는 프로세스 저장.
    - 준비 완료 대기열: CPU 할당을 기다리는 프로세스 저장.
- CPU는 블로킹된 프로세스 대신, 준비 완료 대기열에서 다른 프로세스를 실행.
- 운영체제가 입출력과 CPU를 효율적으로 활용하여 자원을 낭비하지 않도록 함.

### 6.3.4 입출력 완료 후 프로세스 복귀

- 디스크가 입출력을 마치면 인터럽트로 CPU에 작업 완료를 알림.
- 운영체제는 블로킹 대기열에서 해당 프로세스를 준비 완료 대기열로 이동.
- CPU는 기존에 실행 중이던 프로세스의 실행 시간이 끝나면 준비 완료 대기열에서 프로세스를 가져와 실행.
- 결국, 프로세스는 자신이 중단된 줄도 모르고 계속 실행됨.

### 요약

1. 입출력은 단순한 메모리 복사 과정이며, 운영체제가 효율적으로 관리.
2. 디스크 I/O 속도가 느려서, 프로세스는 블로킹되며 운영체제는 다른 프로세스를 실행.
3. 운영체제는 CPU 리소스를 낭비하지 않도록, 스케줄링을 통해 프로세스를 최적으로 배치.
4. 입출력 완료 후 인터럽트를 통해 블로킹된 프로세스를 다시 실행.

# 6.4 높은 동시성의 비결 : 입출력 다중화

유닉스/리눅스에서 모든 것이 파일인 것처럼 모든 입출력 작업은 파일 I/O로 구현할 수 있다.

### 파일 서술자

파일 서술자는 숫자에 불과하다. (인터페이스화 되어 있어서 입출력 기기에 상관 없음)

### 다중 입출력 효율적으로 하는 방법

1. 다중 스레드 (높은 컨텍스트 스위칭 부담)
2. 입출력 다중화 (multiplexing)
    1. 입력을 N개로 다중화 하고, 출력은 역 다중화 한다.

### select, poll, epoll

위 세개는 모두 입출력 다중화 기술

- select
    - 파일 서술자 묶음 1024개 넘을 수 없음
    - 대응되는 프로세스 또는 스레드는 블로킹되며 일시중지
    - 하나라도 I/O 가능 이벤트 발생시 프로세스가 다시 깨어남
    - 어떤 파일 서술자인지 알 수 없어 감시 효율이 매우 떨어짐
- poll
    - select와 동일
    - 파일 서술자 묶음 1024개 넘음, 많을수록 느려짐
- epoll
    - 커널에 데이터 구조 생성
    - 준비 완료 파일 서술자가 목록에 추가됨
    - 매우 높은 동시성의 대명사이다.

# 6.5 파일과 가상 메모리

메모리와 다르게 디스크는 byte가 아닌 block 단위로 주소가 지정된다.

### 파일과 가상 메모리의 연결

- 메모리처럼 파일을 직접 읽고 쓸 수 있을까?
    - 메모리는 직접 주소를 지정해서 접근 가능하지만, 디스크의 파일은 블록 단위로 관리됨.
    - 따라서 파일을 메모리에 맵핑(mmap)하여 가상 메모리처럼 다룰 수 있음.

### 마술사 운영 체제

디스크 공간을 메모리에 사상하게 되면 마치 메모리를 쓰는 것 처럼 디스크를 쓸 수 있다.

사상된 주소 공간을 호출할 때 page fault가 발생하여 메모리와 디스크의 연결이 수립된다.

mmap을 사용하면 여전히 디스크를 IO하지만 이는 OS가 직접 처리한다.

![image](https://github.com/user-attachments/assets/5f879e74-9142-4b92-b55e-75de148d8375)

### mmap이란?

- mmap(Memory Mapping)은 파일을 프로세스의 주소 공간에 매핑하는 기능.
- 특정 파일을 가상 메모리와 연결하여 메모리를 읽고 쓰듯이 파일을 조작 가능.
- 운영체제가 페이지를 관리하며, 필요할 때만 파일의 내용을 메모리에 로드함.

### 6.5.3 mmap vs. 전통적인 `read/write` 방식

| 방식 | 장점 | 단점 |
| --- | --- | --- |
| `read/write` | 단순한 시스템 호출로 사용 가능 | 커널에서 사용자 공간으로 데이터 복사 비용 발생 |
| `mmap` | 데이터 복사가 필요 없음, 대용량 파일 처리에 유리 | 페이지 폴트 발생 가능, 일부 운영체제에서는 오버헤드 존재 |

### mmap과 대용량 파일 처리

- `read/write` 방식은 파일을 잘게 나눠서 처리해야 하지만, mmap을 사용하면 큰 파일도 한 번에 프로세스 주소 공간에 매핑 가능.
- 물리 메모리가 부족해도, 운영체제가 가상 메모리를 활용해 효율적으로 관리.
- 빠른 랜덤 액세스가 필요한 경우 mmap이 유리.

### 동적 링크 라이브러리와 공유 메모리

- 여러 프로세스가 동일한 라이브러리를 사용할 때, 각 프로세스의 주소 공간에 mmap을 이용해 공유 가능.
- 라이브러리 코드를 중복해서 메모리에 적재하지 않기 때문에 메모리 사용량 절약. (100개 적재해도 1개분의 공간만 차지)
- mmap을 이용하면 동적 라이브러리를 각 프로세스가 독립적으로 사용하는 것처럼 보이지만, 실제 물리 메모리는 공유됨.

![image](https://github.com/user-attachments/assets/cbc2e602-9282-487e-a67a-0a5debf387d1)

### mmap 직접 조작하기

- `strace` 명령어를 통해 프로그램이 실행될 때 mmap이 동작하는 모습을 확인 가능.

![image](https://github.com/user-attachments/assets/85b813b8-11a9-47a0-8ed1-35ea07e05072)

- 7번째 줄의 lo.so.cache라는 파일엔 동적 링크 라이브러리의 디스크 경로가 저장됨
- 9번째 줄에선 mmap을 이용해 ls 주소 공간에 사상 (open이 반환한 파일 서술자는 3)
- 12번째 줄의 libselinux.so.1이라는 동적 링크 라이브러리가 열리고 ls 공간에 사상됨
- 20번째 줄의 libselinux.so.6이라는 동적 링크 라이브러리가 열리고 이는 C 표준라이브러리

### 요약

1. mmap을 사용하면 파일을 메모리에 매핑하여 직접 접근 가능.
2. 기존의 `read/write` 방식은 데이터 복사가 필요하지만, mmap은 이를 생략하여 성능을 향상.
3. 대용량 파일 처리 시 mmap이 유리하며, 랜덤 액세스 성능이 좋음.
4. 동적 링크 라이브러리는 mmap을 이용해 메모리를 효율적으로 공유.
5. mmap은 운영체제의 가상 메모리 관리와 결합되어 작동하며, 성능 비교 후 적절히 선택해야 함.

# 6.6 컴퓨터 시스템의 지연 시간

### 지연 시간 통계

제프 딘이 2012년에 발표한 컴퓨터 시스템의 전형적인 작업에서 발생하는 지연 시간 통계

![image](https://github.com/user-attachments/assets/2a9fbb87-f233-4a23-ae6a-9f9d29295bff)

주요 지표를 살펴보자면

- L1 캐시 접근: 0.5 ns
- 메모리 접근: 100 ns
- 디스크 탐색: 10,000,000 ns
- 네트워크 패킷 전송 (CA->네덜란드->CA): 150,000,000 ns
- 캐시와 메모리 접근 시간: L1 캐시 접근 시간에 비해 L2 캐시는 14배, 메모리는 200배 더 느리다. →  CPU와 메모리 사이에 캐시 계층이 필요
- 디스크와 SSD 접근 시간: 디스크는 SSD보다 20배, 메모리보다 80배 느리다.
→ 디스크 탐색 시간은 특히 느리기 때문에 고성능 데이터베이스는 순차 기록 방식을 사용

etc

- 분기 예측 실패의 대가: 5ns

### 시간 지표로 환산

- 0.5ns를 1초로 환산: 컴퓨터의 지연 시간을 쉬운 시간 단위로 환산
    - L1 캐시 접근: 1초
    - 메모리 접근: 3분
    - 디스크 탐색: 200일
    - 컴퓨터 재시작: 5,600년

### 거리 지표로 환산

- 0.5ns를 1m로 환산: 지연 시간을 거리 단위로 환산
    - L1 캐시 접근: 1m (집 안에서 택배를 가져오는 거리)
    - 메모리 접근: 200m (편의점에 다녀오는 거리)
    - 디스크 탐색: 40,000km (지구 한 바퀴)
    - 네트워크 패킷 전송 (CA->네덜란드->CA): 300,000km (지구에서 달까지의 거리)
    - 컴퓨터 재시작: 240,000,000km (지구에서 화성까지의 거리)

# 6.7 요약

- 입출력의 중요성: CPU는 메모리와 외부 장치와 상호 작용해야 하며, 외부 장치의 데이터는 CPU와 비동기적으로 처리된다. 
→ 효율적인 입출력 처리와 하드웨어 리소스 활용이 중요
- 운영 체제의 역할: 인터럽트, DMA, 스케줄링 등을 통해 다양한 하드웨어 리소스를 효율적으로 관리
- 컴퓨터 시스템의 비밀: 프로그래밍 언어, 운영 체제, 메모리 관리, CPU 동작 원리, 캐시 계층, 입출력 등 컴퓨터 시스템의 저수준 계층을 깊이 있게 이해하는 것이 중요
