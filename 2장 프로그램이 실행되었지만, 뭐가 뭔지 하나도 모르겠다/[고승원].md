# 2장 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다

학습 포인트

- 프로세스, 스레드
- 콜백 함수, 동기화, 비동기화, 블로킹, 논블로킹
- 코루틴

# 2.1 운영 체제, 프로세스, 스레드의 근본 이해하기

## 2.1.1 모든 것은 CPU에서 시작된다

CPU가 명령어 실행하는 과정

1. 메모리에서 명령어(instruction)를 하나 가져온다(dispatch)
2. 이 명령어를 실행(excute) 한 뒤 1로 돌아간다.

![image](https://github.com/user-attachments/assets/ab77deed-b097-468a-95df-c5aaf15911d5)

- CPU는 PC라는 레지스터에서 명령어를 가져와서 실행 한다.
- PC 레지스터에 저장된 명령어는 메모리에 저장된 명령어의 주소다.
- PC 레지스터가 저장하는 명령어 주소는 1씩 자동으로 증가하는데, 순차적으로 실행되는 것은 아니다.
- 최초 PC 레지스터의 값은 메모리에 저장 → 디스크에 저장 → 컴파일러가 실행 파일 적재된 명령어다.
- 시작점은 프로그램이 작성된 코드에서 시작한다. (main 함수)

## 2.1.2 CPU에서 운영 체제까지

프로그램 직접 실행하는 법

- 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾는다.
- CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC 레지스터를 설정한다.

직접 실행하는 방법의 단점

1. 한 번에 하나의 프로그램만 실행 가능 (멀티 태스킹 불가)
2. 모든 프로그램을 사용할 하드웨어를 직접 드라이버와 연결해야 한다.
3. 간단한 print함수도 직접 구현해야 한다.
4. 상호 작용 인터페이스도 직접 구현해야 한다.

멀티태스킹 방법 : 여러 프로그램을 빠르게 번갈아가며 실행한다.

일시 중지 방법 : CPU 내부의 레지스터, 상태 값을 저장해서 context를 잠시 중지한다.

운영 체제는 다음과 같은 기능으로 실행 파일을 수동으로 유지 관리할 필요가 없어졌다.

## 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다.

![image](https://github.com/user-attachments/assets/96fb573c-966f-48ac-9d4d-d1b30a364bef)

프로세스가 실행중일 때 메모리 주소 공간

- 코드 영역 : 코드를 컴파일하여 생성된 기계 명령어가 저장된다.
- 데이터 영역 : 전역 변수 등이 저장된다.
- 힙 영역 : 함수가 요청을 반환한 메모리가 할당된다.
- 스택 영역 : 함수의 실행 시간 스택이다.

독립적인 여러 프로세스에서 실행 속도를 높일 방법 → 다중 프로세스 프로그래밍 + 프로세스 간 통신

![image](https://github.com/user-attachments/assets/5d451057-83f5-481e-b046-acdb90d87765)

단점

1. 프로세스를 생성할 때 비교적 큰 overhead
2. 프로세스마다 자체적인 주소 공간이 있어서 프로세스간 통신 복잡

## 2.1.4 프로세스에서 스레드로 진화

프로세스의 단점은 진입함수가 main 하나여서 한 번에 하나의 CPU에서만 실행할 수 있다.

진입함수인 main 함수가 특별한 함수다? 

→ X 아니다. 다른 함수를 PC 레지스터가 가리키게 하면 새로운 실행 흐름이 생긴다.

가장 중요한 점은 이런 실행 흐름이 동일한 **프로세스 주소 공간을 공유**해서 **프로세스 간 통신이 필요 없다**. → 하나의 프로세스에 기계 명령어를 CPU 여러개에서 동시에 실행 가능 (스레드의 탄생)

![image](https://github.com/user-attachments/assets/27b4c649-71ec-4a24-8717-4d6f5e8b1944)

스레드를 사용하면 프로세스 간 통신이 일어나지 않는다. (같은 주소 공간을 사용하기 때문)

이런 이유에서 스레드를 경량 프로세스라고 하기도 한다.

스레드의 사용처

- 다중 코어를 충분히 활용하기 위함
- GUI에서 이벤트 처리할 때 응답을 위한 스레드 생성

## 2.1.5 다중 스레드와 메모리 구조

함수가 실행될 때 필요한 정보

- 매개변수
- 지역변수
- 반환 주소

함수가 실행될 때 스택 프레임을 갖는데, 이는 후입선출 순서로 증감하며 프로세스 주소공간에 형성된다.

## 2.1.6 스레드의 활용 예

### 긴 작업

Word와 같이 긴 시간 한 작업을 하는 경우에 해당된다.

보통 스레드의 수명 주기와 작업의 수명 주기가 같음

이런 경우 전용 스레드를 생성한다.

### 짧은 작업

웹 서버, 데이터베이스, 파일 서버 등

스레드를 매번 생성/삭제 하면 자원 낭비가 심하기 때문에 스레드풀로 처리

### 2.1.7 스레드 풀의 동작 방식

스레드 풀을 사용해 미리 생성해 두고 사용한다.

재사용을 통해 불필요한 메모리 소비를 하지 않는다

![image](https://github.com/user-attachments/assets/abc2958b-f4bd-44e8-8f35-bb6a3934dc77)

1. 작업 대기열에 블로킹 상태로 대기
2. 작업 대기열에서 데이터 꺼내기
3. 데이터 처리하기

## 2.1.8 스레드 풀의 스레드 수

```jsx
N * (1 + WT / CT)

N은 코어 갯수
WT는 입출력 대기 시간
CT CPU 연산 시간
```

# 2.2 스레드 간 고유되는 프로세스 리소스

## 2.2.1 스레드 전용 리소스

스레드 = 함수 실행

![image](https://github.com/user-attachments/assets/fc2ea4e8-0cec-4fdc-8afe-1f7d1d249eb1)

스레드는 자신만의 스택 영역, PC, 스택 포인터, 레지스터 정보를 가진다.

→ thread context라고 부른다.

## 2.2.2 코드 영역: 모든 함수를 스레드에 배치하여 실행할 수 있다.

코드 영역은 프로세스 공간에 저장되기 때문에 특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가능하다.

코드 영역은 read-only여서 동시성 문제가 발생하지 않는다.

## 2.2.3 데이터 영역: 모든 스레드가 데이터 영역의 변수에 접근할 수 있다

전역 변수는 데이터 영역에 적재되는데, 전역 변수의 인스턴스는 하나만 있어서 모든 스레드는 이에 접근이 가능하다.

## 2.2.4 힙 영역: 포인터가 핵심

포인터(주소)만 알고 있으면 데이터에 접근이 가능하다.

## 2.2.5 스택 영역: 공유 공간 내 전용 데이터

추상화 측면에서 바라본 스택 영역은 스레드 전용 공간이다.

구현 측면에서 바라본 스택 영역은 스레드 전용 공간은 아니다.

→ 다른 스레드로부터 포인터만 가져오면 그 스레드의 스택 영역을 읽고 쓸 수 있다.

→ 이는 수많은 문제를 일으킬 가능성이 높아서 이런식의 코드는 작성하면 안된다.

## 2.2.6 동적 링크 라이브러리와 파일

동적 링크의 라이브러리 코드와 데이터는 주소 공간의 어디에 놓일까?

→ 스택 영역과 힙 영역 중간의 여유 공간에 배치한다. (스레드 간 공유)

* 스레드 주소 공간에 열린 파일 정보도 공유 리소스에 속한다.

## 2.2.7 스레드 전용 저장소

- 이 영역에 저장된 변수는 모든 스레드에서 접근 가능
- 변수의 인스턴스는 각각의 스레드에 속한다. (다른 스레드에 동기화 되지 않음)

# 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

## 2.3.1 자유와 계약

스레드 세이프 하려면 두가지 조건이 있다.

- 전용 리소스 사용
- 공유 리소스를 사용할 때 대기 제약 조건에 맞게 사용

## 2.3.3 스레드 전용 리소스와 공유 리소스

공유 리소스

- **힙 영역** : 메모리의 동적 할당에 사용되는 영역 (함수, new 예약어)
- **데이터 영역** : 전역 변수가 저장되는 영역
- 코드 영역 : 읽기 전용으로 신경쓸 필요 없음

스레드 전용 리소스

- 스택 영역
- 여유 공간

공유 리소스를 사용할 땐 lock이나 semaphore같은 장치를 사용해야 한다.

## 2.3.5 스레드 전용 리소스와 함수 매개변수

**call by value의 경우 문제 없음 (스택 영역)**

만일 스택 영역의 자원의 포인터를 전달하게 된다면 그때부턴 **작업 순서를 보장**해야 한다.

따라서 스레드 간에 공유 리소스를 사용하지 않도록 해야 한다.

## 2.3.6 전역 변수 사용

변수를 읽기만 한다면 문제 되지 않는다.

## 2.3.7 스레드 전용 저장소

__thread 수식어가 붙은 변수는 스레드 전용 저장소에 배치된다.

= thread safe

## 2.3.8 함수 반환값

retur nby value : thrad safe

return by reference : 스레드간 공유가 가능해져서 절대 하지 않는 것을 권장 (singleton 제외)

## 2.3.9 스레드 안전이 아닌 코드 호출하기

thread safe한 작업이 아닐 때는 함수를 호출하기 전에 잠금으로 보호하면 된다.

나의 생각 : 그냥 function을 thread safe하게 만들고, 공유 리소스를 건드는 부분만 신경써주면 안되나

## 2.3.10 스레드 안전 코드는 어떻게 구현할까?

thread safe 하려면 스레드 전용 리소스와 스레드 공유 리소스인지 파악해야 한다.

- 스레드 전용 저장소 : 전역 리소스를 사용해야 하는 경우 고려하라
- 읽기 전용 : 읽기 전용 리소스는 thread safe하니 십분 활용하라
- 원자성 연산 : 중간에 중단되지 않으므로 lock같은 잠금이 필요 없다
- 동기화 시 상호배제 : mutex, spin lock, semaphore 등으로 상호 배제 한다.

# 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?

## 2.4.1 일반 함수

함수가 호출되면 순차적으로 실행

반환값을 가지고 호출지점으로 돌아감

## 2.4.2 일반 함수에서 코루틴으로

일반 함수와 형식의 차이는 없지만 일시 중지와 재개 기능이 있다.

자신의 실행 상태를 저장할 수 있기 때문에 코루틴이 반환된 후에도 계속 호출이 가능하며, 더군다나 마지막으로 일시 중지된 지점에서 다시 이어서 실행된다

```python
# python code 입니다
def func():
	print("a")
	yield
	print("b")
	yield
	print("c")
```

위 함수는 yield라는 명령어로 코루틴이 되었다.

```python
def A():
	co = funt()
	next(co)
	print("in funciton A")
	next(co)
```

위 함수를 실행하면

```python
a
in function A
b
```

## 2.4.3 직관적인 코루틴 설명

일반 함수 호출의 실행 흐름

![image](https://github.com/user-attachments/assets/e99b8a3c-e7a0-43f3-a4ce-43e2faa84ef5)

코루틴 호출의 실행 흐름

![image](https://github.com/user-attachments/assets/0e87b7b6-0d65-48dc-b392-152f8d6a7333)

## 2.4.4 함수는 그저 코루틴의 특별한 예에 불과하다

코루틴은 운영체제에서 스레드를 멈췄다가 다른 스레드의 스케줄링을 진행하는 것과 똑같다.

유의할점

- 타이머 인터럽트를 위한 작동방식이 없어 반드시 **일시중지 지점을 명시**해야 한다.
- OS 코루틴을 알지 못한다. 따라서 제어권은 사용자에게 있다.

## 2.4.5 코루틴의 역사

코루틴을 사용하기 좋은 곳 → 높은 성능과 동시성을 요구하는 분야

## 2.4.6 코루틴은 어떻게 구현될까?

스레드와 본질적으로 차이가 없음

코루틴은 일시 중지될 때 상태 정보를 반드시 기록한다. (힙 영역에 저장)

- CPU 레지스터 정보
- 함수 실행 시 상태 정보

이론적으로 메모리 공간이 충분하다면 코루틴 개수에 제한은 없으며 전환이나 스케줄링은 전적으로 사용자 상태에서 일어나기 때문에 OS가 개입할 필요가 없다.

또한, 프로그래머가 **동기 방식으로 비동기 프로그래밍**을 가능하게 한다.

# 2.5 콜백 함수를 철저하게 이해한다.

## 2.5.2 콜백이 필요한 이유

함수를 수만가지로 분개해야 할 때 함수를 변수처럼 사용할 수 있다. (콜백 함수)

분개하지 않고, 함수를 직접 전달하면 되기 때문이다.

## 2.5.3 비동기 콜백

함수가 너무 긴 시간 실행되는 상황이 발생하면 내부에 스레드를 생성하여 실행시키고 반환할 수 있다.

이를 비동기 작업이라 한다.

이와 같이 호출 스레드가 콜백 함수 실행에 의존하지 않는 것을 비동기 콜백이라고 한다.

## 2.5.4 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다

동기

1. 함수를 호출하고 결과를 획득
2. 획득한 결과를 처리

비동기

1. 함수 호출 스레드에서 호출 처리
2. 또다른 스레드에서 로직 처리

## 2.5.5 콜백 함수의 정의

콜백 함수 : 다른 코드에 매개변수로 전달되는 실행 가능한 코드

콜백 함수가 호출되는 시점

- 특정 이벤트가 발생하면 이를 처리하고 싶을 때
- 즉 event handler, event-driven programming에 적합하다.

## 2.5.6 두 가지 콜백 유형

동기 콜백(blocking callback) → 호출 함수가 반환되기 전에 실행

비동기 콜백(deferred callback) → 실행 시간은 상관관계 없음 / 서로 다른 스레드 or 프로세스에서 실행

비동기 콜백이 다중 코어 리로스 활용에 더 좋다.

## 2.5.7 비동기 콜백의 문제: 콜백 지옥

동기 서비스와 비동기 서비스의 결과 사용은 개수가 많아질수록 복잡해진다.

```python
동기
a = GetA();
b = GetB(a);
c = GetC(b);
d = GetD(c);

비동기
getA(function(a)
	{
		getB(a, function(b)
			{
				getC(b, function(c)
					{
						getD(c, function(d)
							{
								...
							}
						);
					}
				);
			}
		);
	}
);
```

이 콜백 지옥을 해결해줄 수 있는게 코루틴이다.

# 2.6 동기와 비동기를 철저하게 이해한다.

## 2.6.3 동기 호출

![image](https://github.com/user-attachments/assets/fa070b60-92e3-46cf-8d92-efec859b5e05)

## 2.6.4 비동기 호출

![image](https://github.com/user-attachments/assets/b027146f-b912-4fa7-8063-1a87fa1f103c)

특징

- 호출자는 즉시 다음 작업을 할 수 있다.
- 프로그래머가 이해/코딩 하는데 큰 부담이 될 수 있다.
- 작업 완료 여부 판단
    - 호출자가 신경쓸 때 → 콜백 함수를 사용해 호출하는 or 호출되는 스레드에서 실행
    - 호출자가 신경쓰지 않을 때

## 2.6.5 웹 서버에서 동기와 비동기 작업

가정

- DB 요청
- ABC 작업 후 DB에 요청
- DB요청 처리 완료되면 DEF 작업

동기

![image](https://github.com/user-attachments/assets/e1d6c24e-86d5-4173-9908-91c57fc1c7bb)

주 스레드에 idle time이 발생한다.

비동기 - DB 처리상황 상관 없음

![image](https://github.com/user-attachments/assets/ffc955c1-b5d9-4da6-af7b-b9f0ac34d653)

주 스레드에 idle time이 사라졌다. 하지만 이해하기 어렵고, 유지보수 난이도도 올라간다.

비동기 - DB 처리상황 상관 있음

![image](https://github.com/user-attachments/assets/6869b727-dc58-47b1-9fd8-846ff4c9d74d)

동기 호출에 비해 효율적이나, 위의 상황보단 비효율 적임

# 2.7 아 맞다! 블로킹과 논블로킹도 있다

의존 관계 : 동기

독립 관계 : 비동기

## 2.7.1 블로킹과 논블로킹

블로킹 : A함수가 B함수를 호출할 때 호출함과 동시에 A함수가 중지되는 경우

논블로킹 : 블로킹 방식을 제외한 방식

## 2.7.2 블로킹의 핵심 문제 : 입출력

Disk I/O가 있을 때 ms 단위의 시간이 소요되는데 이동안 CPU가 일하게 해야 한다. 

→ I/O 하는 시간동안 다른 스레드의 함수를 실행시킨다. 

→ I/O가 오래걸리면 호출 스레드가 블로킹되며 일시정지되는 일이 발생한다.

→ 논블로킹

## 2.7.3 논블로킹과 비동기 입출력

논블로킹 함수 recv를 호출하면 즉시 함수를 반환하고 스레드는 커널에게 작업을 위임하게 된다.

그럼 스레드와 커널 두 가지는 병행 처리된다.

위 상황에서 데이터 수신 여부를 판단하는 방법

1. 논블로킹 방식에 recv 함수 외에 결과 확인 함수를 만들어 호출한다.
2. 데이터가 수신되면 스레드에 메시지나 신호 등 알림을 사용한다.
3. recv 함수를 호출할 때 데이터 수신을 담당하는 콜백 함수를 매개변수로 전달한다.

이것이 바로 **논블로킹**이자, **비동기 입출력**이다.

## 2.7.4 피자 주문에 비유하기

피자를 전화로 주문했을 때 완성 유무를 어떻게 알 수 있을까?

1. 배달이 완료되면 전화가 올테니 느긋하게 기다린다.
2. 5분마다 전화하여 완성 유무를 묻는다.
    1. 완성 유무를 묻는 것 외에 아무 행동을 하지 않는다면 **동기**다.

**논블로킹 ≠ 비동기**

## 2.7.5 동기와 블로킹

동기 ≠ 블로킹

블로킹 = 동기

전후관계를 잘 확인할 것

동기와 비동기는 호출함 함수가 반환될 때 까지 기다리는 것을 유무로 따진다.

블로킹과 논블로킹은 다른 함수가 실행되는 동안 현재 함수가 다른 작업을 수행할 수 있음을 따진다.

```python
int sum(int a, int b)
{
return a+b;
}

void funcA()
{
sum(1,1);
}
```

위의 함수에선 1+1은 매우 간단한 함수여서 **즉시 반환**된다.

블로킹 요소 : I/O 작업, 락 대기, 네트워크 호출 등

따라서 CPU가 유휴 상태로 대기하는 시간이 없음 → "블로킹"이라고 할 수 없음

## 2.7.6 비동기와 논블로킹

논블로킹 함수를 호출할 때 handler 함수를 바로 사용할 수 없으면 이는 논블로킹 이지만, 동기다.

```python
while(true)
{
	fd = accept();
	recv(blahblah);
	
	while(!check(fd))
	{
		//순환감지
		//계속 전화로 피자를 확인하는 모습
	}
	
	handler(buf);
}
```

# 2.8 높은 동시성과 고성능을 갖춘 서버 구현

## 2.8.1 다중 프로세스

리눅스에서 fork 방식으로 여러 자기 프로세스를 생성할 수 있다.

장점

- 프로그래밍이 매우 간단함
- 개별 프로세스의 주소 공간이 격리되어 있어 서로 영향이 없다.
- 다중 코어 리소스를 최대한 활용할 수 있다.

단점

- 프로세스 간 통신 난이도가 높다.
- 프로세스를 생성/종료할 때 부담이 된다.

## 2.8.2 다중 스레드

프로세스 생성에 대한 부담을 스레드가 해결해준다.

장점

- 프로세스 생성/삭제가 부담스럽지 않다.
- 프로세스 간 통신이 필요 없다.

단점

- 스레드간 영향도가 커서 장애시 다같이 죽는다.
- 공유 자원에 대한 동시성 문제를 일으킬 수 있다.

## 2.8.3 이벤트 순환과 이벤트 구동

GUI나 서버 프로그래밍에서 널리 사용되는 event driven programming이다.

이벤트가 도착하면 이벤트 유형에 따라 대응하는 이벤트 핸들러를 찾아 직접 핸들러를 호출하면 된다.

이벤트는 계속 수신하고 처리해야 하기 때문에 반복문을 사용하여 반복적으로 처리할 필요가 있다.(이는 이벤트 순환)

필요 요소

1. 이벤트 : 서버를 다루고 있기 때문에 대부분 입출력에 관한 것 (네트워크, 데이터, 파일 등)
2. 이벤트를 처리하는 함수 : 이벤트 핸들러

해결해야 할 문제

1. 함수 하나로 이벤트를 어떻게 분기처리할 지 → I/O multiplexing
2. 이벤트 handler가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 하나?

## 2.8.4 첫 번째 문제 : 이벤트 소스와 입출력 다중화(I/O multiplexing)

리눅스와 유닉스에선 모든 것이 파일로 취급되어 file descriptor를 사용하여 I/O 작업을 실행한다. (소켓또한)

사용자 연결 열 개를 어떻게 수신할 수 있을까?

- 순차 처리 → X
- 소켓을 감시하고 있다가 데이터가 들어오면 알림을 보낸다 → epoll

![image](https://github.com/user-attachments/assets/65c62a11-8d8d-4659-ac7e-bf8ab9510ef3)

## 2.8.5 두 번째 문제 : 이벤트 순환과 다중 스레드

이벤트 순환과 핸들러가 같은 스레드를 사용하는 경우 시간이 오래 걸린다.

반응자 패턴 : 이벤트 순환과 핸들러 스레드는 각각 다른 스레드이며, 이벤트 순환 스레드가 핸들러 스레드에게 작업을 분배한다.

![image](https://github.com/user-attachments/assets/13dec6cc-a1b8-4c94-ade5-193fcfc8771b)

## 2.8.7 이벤트 순환과 입출력

가정

1. 입출력 작업에 대응하는 논블로킹 인터페이스가 있는 경우 : 인터페이스를 호출해도 바로 반환되므로 이벤트 순환에서 직접 호출하는게 가능하다.
2. 입출력 작업에 블로킹 인터페이스만 있는 경우 : 이벤트 순환에서 **절대로 블로킹 인터페이스를 호출하면 안 된다.** 이벤트 순환 스레드가 중지될 위험에 노출되기 때문

![image](https://github.com/user-attachments/assets/c6728779-969f-4344-9e25-a99809b67bd9)

## 2.8.8 비동기와 콜백 함수

가정 

- 하나의 요청을 위해 N개의 서버가 관여한다.
- 각 요청은 순차적으로 응답값을 사용한다.

각 서버는 RPC 호출을 사용하는데 이는 모두 블로킹 호출이다.

블로킹 호출은 코드가 명확하고 쉽지만, 스레드가 빈번하게 중단될 수 있다는 단점이 있다.

## 2.8.9 코루틴 : 동기 방식의 비동기 프로그래밍

프로그래밍 언어나 프레임워크가 코루틴을 지원하면 handler를 코루틴에서 실행할 수 있다.

handler 함수는 여전히 동기로 작성되지만, yield로 CPU 제어권을 반환하는 등 다른점이 있다.

- RPC 호출 함수나 네트워크 데이터 전송 함수를 수정해야 한다.
- 동기 방식으로 프로그래밍 해도 비동기 실행과 같은 효과를 얻는다.

![image](https://github.com/user-attachments/assets/746c3273-3186-4941-a14b-652a602f4ab8)

## 2.8.10 CPU, 스레드, 코루틴

CPU : 하드웨어 계층, 스레드 제어

스레드 : 커널 계층, 코루틴 제어

코루틴 : 사용자 계층

스레드 : 커널단계여서 CPU 연산 리소스 할당

코루틴 : 커널이 몰라서 개수에 상관 없이 스레드에 따라 CPU 시간 할당

# 2.9 컴퓨터 시스템 여행 : 데이터, 코드, 콜백, 클로저에서 컨테이너, 가상 머신까지

## 2.9.1 코드, 데이터, 변수, 포인터

초기의 명령어 집합이 함수가 되었고, 저장된 데이터를 지칭하는 변수가 되었다.

데이터를 지칭하는 변수를 포인터 또는 참조라고 한다.

## 2.9.2 콜백 함수와 클로저

특정 언어에서 코드를 할당, 사용, 매개변수 등 일반 변수를 다루듯이 처리할 수 있을 때 **일급 객체 함수**라고 한다.

C에선 함수가 일급 객체가 아니지만, 파이썬에선 일급 객체이므로 변수처럼 사용 가능하다.

콜백 함수는 매우 유용하지만 정의와 호출을 다른 곳에서 하기 때문에 실행 시간, 데이터를 콜백함수가 사용할 수 있어야 한다. → 콜백함수와 일부 데이터를 묶은 변수인 클로저 탄생

## 2.9.3 컨테이너와 가상 머신 기술

코루틴 : 함수가 CPU를 능동적으로 중지/재개 하는 것

스레드 : 함수의 일시 중지와 재개가 커널 상태에서 구현되는 경우

프로세스 : 스레드에 주소 공간처럼 종속된 실행 시 리소스를 결합한 것

컨테이너 : 프로그램 구성, 라이브러리가 의존하는 실행 환경과 함께 묶은 것

컨테이너의 이점

- 서로 격리되어 있다.
- 장기간 반복 사용이 가능하다
- 적재와 하역이 빠르다.
- 표준 크기로 구성되어 있다.

컨테이너는 운영 체제까지 가상화 하여 컨테이너에 포함된 프로세스가 자신만 존재하고 있다고 간주하게 한다.

하드웨어 가상화는 하드웨어를 추상화하고 여러개의 가상 컴퓨터로 나눠 실행한다. (hybervisor가 리소스 작업을 하도록 해준다)

CPU/메모리 가상화는 가상 CPU/메모리 내에 본인만 독점소유하고 있다고 간주하게 하는데, 이는 컨테이너와 매우 유사하다.
