# 2장 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다

학습 포인트

- 프로세스, 스레드
- 콜백 함수, 동기화, 비동기화, 블로킹, 논블로킹
- 코루틴

# 2.1 운영 체제, 프로세스, 스레드의 근본 이해하기

## 2.1.1 모든 것은 CPU에서 시작된다

CPU가 명령어 실행하는 과정

1. 메모리에서 명령어(instruction)를 하나 가져온다(dispatch)
2. 이 명령어를 실행(excute) 한 뒤 1로 돌아간다.

![image](https://github.com/user-attachments/assets/ab77deed-b097-468a-95df-c5aaf15911d5)

- CPU는 PC라는 레지스터에서 명령어를 가져와서 실행 한다.
- PC 레지스터에 저장된 명령어는 메모리에 저장된 명령어의 주소다.
- PC 레지스터가 저장하는 명령어 주소는 1씩 자동으로 증가하는데, 순차적으로 실행되는 것은 아니다.
- 최초 PC 레지스터의 값은 메모리에 저장 → 디스크에 저장 → 컴파일러가 실행 파일 적재된 명령어다.
- 시작점은 프로그램이 작성된 코드에서 시작한다. (main 함수)

## 2.1.2 CPU에서 운영 체제까지

프로그램 직접 실행하는 법

- 프로그램을 적재할 수 있는 적절한 크기의 메모리 영역을 찾는다.
- CPU 레지스터를 초기화하고 함수의 진입 포인트를 찾아 PC 레지스터를 설정한다.

직접 실행하는 방법의 단점

1. 한 번에 하나의 프로그램만 실행 가능 (멀티 태스킹 불가)
2. 모든 프로그램을 사용할 하드웨어를 직접 드라이버와 연결해야 한다.
3. 간단한 print함수도 직접 구현해야 한다.
4. 상호 작용 인터페이스도 직접 구현해야 한다.

멀티태스킹 방법 : 여러 프로그램을 빠르게 번갈아가며 실행한다.

일시 중지 방법 : CPU 내부의 레지스터, 상태 값을 저장해서 context를 잠시 중지한다.

운영 체제는 다음과 같은 기능으로 실행 파일을 수동으로 유지 관리할 필요가 없어졌다.

## 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다.

![image](https://github.com/user-attachments/assets/96fb573c-966f-48ac-9d4d-d1b30a364bef)

프로세스가 실행중일 때 메모리 주소 공간

- 코드 영역 : 코드를 컴파일하여 생성된 기계 명령어가 저장된다.
- 데이터 영역 : 전역 변수 등이 저장된다.
- 힙 영역 : 함수가 요청을 반환한 메모리가 할당된다.
- 스택 영역 : 함수의 실행 시간 스택이다.

독립적인 여러 프로세스에서 실행 속도를 높일 방법 → 다중 프로세스 프로그래밍 + 프로세스 간 통신

![image](https://github.com/user-attachments/assets/5d451057-83f5-481e-b046-acdb90d87765)

단점

1. 프로세스를 생성할 때 비교적 큰 overhead
2. 프로세스마다 자체적인 주소 공간이 있어서 프로세스간 통신 복잡

## 2.1.4 프로세스에서 스레드로 진화

프로세스의 단점은 진입함수가 main 하나여서 한 번에 하나의 CPU에서만 실행할 수 있다.

진입함수인 main 함수가 특별한 함수다? 

→ X 아니다. 다른 함수를 PC 레지스터가 가리키게 하면 새로운 실행 흐름이 생긴다.

가장 중요한 점은 이런 실행 흐름이 동일한 **프로세스 주소 공간을 공유**해서 **프로세스 간 통신이 필요 없다**. → 하나의 프로세스에 기계 명령어를 CPU 여러개에서 동시에 실행 가능 (스레드의 탄생)

![image](https://github.com/user-attachments/assets/27b4c649-71ec-4a24-8717-4d6f5e8b1944)

스레드를 사용하면 프로세스 간 통신이 일어나지 않는다. (같은 주소 공간을 사용하기 때문)

이런 이유에서 스레드를 경량 프로세스라고 하기도 한다.

스레드의 사용처

- 다중 코어를 충분히 활용하기 위함
- GUI에서 이벤트 처리할 때 응답을 위한 스레드 생성

## 2.1.5 다중 스레드와 메모리 구조

함수가 실행될 때 필요한 정보

- 매개변수
- 지역변수
- 반환 주소

함수가 실행될 때 스택 프레임을 갖는데, 이는 후입선출 순서로 증감하며 프로세스 주소공간에 형성된다.

## 2.1.6 스레드의 활용 예

### 긴 작업

Word와 같이 긴 시간 한 작업을 하는 경우에 해당된다.

보통 스레드의 수명 주기와 작업의 수명 주기가 같음

이런 경우 전용 스레드를 생성한다.

### 짧은 작업

웹 서버, 데이터베이스, 파일 서버 등

스레드를 매번 생성/삭제 하면 자원 낭비가 심하기 때문에 스레드풀로 처리

### 2.1.7 스레드 풀의 동작 방식

스레드 풀을 사용해 미리 생성해 두고 사용한다.

재사용을 통해 불필요한 메모리 소비를 하지 않는다

![image](https://github.com/user-attachments/assets/abc2958b-f4bd-44e8-8f35-bb6a3934dc77)

1. 작업 대기열에 블로킹 상태로 대기
2. 작업 대기열에서 데이터 꺼내기
3. 데이터 처리하기

## 2.1.8 스레드 풀의 스레드 수

```jsx
N * (1 + WT / CT)

N은 코어 갯수
WT는 입출력 대기 시간
CT CPU 연산 시간
```

# 2.2 스레드 간 고유되는 프로세스 리소스

## 2.2.1 스레드 전용 리소스

스레드 = 함수 실행

![image](https://github.com/user-attachments/assets/fc2ea4e8-0cec-4fdc-8afe-1f7d1d249eb1)

스레드는 자신만의 스택 영역, PC, 스택 포인터, 레지스터 정보를 가진다.

→ thread context라고 부른다.

## 2.2.2 코드 영역: 모든 함수를 스레드에 배치하여 실행할 수 있다.

코드 영역은 프로세스 공간에 저장되기 때문에 특정 함수를 특정 스레드에서만 실행되도록 하는 것은 불가능하다.

코드 영역은 read-only여서 동시성 문제가 발생하지 않는다.

## 2.2.3 데이터 영역: 모든 스레드가 데이터 영역의 변수에 접근할 수 있다

전역 변수는 데이터 영역에 적재되는데, 전역 변수의 인스턴스는 하나만 있어서 모든 스레드는 이에 접근이 가능하다.

## 2.2.4 힙 영역: 포인터가 핵심

포인터(주소)만 알고 있으면 데이터에 접근이 가능하다.

## 2.2.5 스택 영역: 공유 공간 내 전용 데이터

추상화 측면에서 바라본 스택 영역은 스레드 전용 공간이다.

구현 측면에서 바라본 스택 영역은 스레드 전용 공간은 아니다.

→ 다른 스레드로부터 포인터만 가져오면 그 스레드의 스택 영역을 읽고 쓸 수 있다.

→ 이는 수많은 문제를 일으킬 가능성이 높아서 이런식의 코드는 작성하면 안된다.

## 2.2.6 동적 링크 라이브러리와 파일

동적 링크의 라이브러리 코드와 데이터는 주소 공간의 어디에 놓일까?

→ 스택 영역과 힙 영역 중간의 여유 공간에 배치한다. (스레드 간 공유)

* 스레드 주소 공간에 열린 파일 정보도 공유 리소스에 속한다.

## 2.2.7 스레드 전용 저장소

- 이 영역에 저장된 변수는 모든 스레드에서 접근 가능
- 변수의 인스턴스는 각각의 스레드에 속한다. (다른 스레드에 동기화 되지 않음)

# 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?

## 2.3.1 자유와 계약

스레드 세이프 하려면 두가지 조건이 있다.

- 전용 리소스 사용
- 공유 리소스를 사용할 때 대기 제약 조건에 맞게 사용

## 2.3.3 스레드 전용 리소스와 공유 리소스

공유 리소스

- **힙 영역** : 메모리의 동적 할당에 사용되는 영역 (함수, new 예약어)
- **데이터 영역** : 전역 변수가 저장되는 영역
- 코드 영역 : 읽기 전용으로 신경쓸 필요 없음

스레드 전용 리소스

- 스택 영역
- 여유 공간

공유 리소스를 사용할 땐 lock이나 semaphore같은 장치를 사용해야 한다.

## 2.3.5 스레드 전용 리소스와 함수 매개변수

**call by value의 경우 문제 없음 (스택 영역)**

만일 스택 영역의 자원의 포인터를 전달하게 된다면 그때부턴 **작업 순서를 보장**해야 한다.

따라서 스레드 간에 공유 리소스를 사용하지 않도록 해야 한다.

## 2.3.6 전역 변수 사용

변수를 읽기만 한다면 문제 되지 않는다.

## 2.3.7 스레드 전용 저장소

__thread 수식어가 붙은 변수는 스레드 전용 저장소에 배치된다.

= thread safe

## 2.3.8 함수 반환값

retur nby value : thrad safe

return by reference : 스레드간 공유가 가능해져서 절대 하지 않는 것을 권장 (singleton 제외)

## 2.3.9 스레드 안전이 아닌 코드 호출하기

thread safe한 작업이 아닐 때는 함수를 호출하기 전에 잠금으로 보호하면 된다.

나의 생각 : 그냥 function을 thread safe하게 만들고, 공유 리소스를 건드는 부분만 신경써주면 안되나

## 2.3.10 스레드 안전 코드는 어떻게 구현할까?

thread safe 하려면 스레드 전용 리소스와 스레드 공유 리소스인지 파악해야 한다.

- 스레드 전용 저장소 : 전역 리소스를 사용해야 하는 경우 고려하라
- 읽기 전용 : 읽기 전용 리소스는 thread safe하니 십분 활용하라
- 원자성 연산 : 중간에 중단되지 않으므로 lock같은 잠금이 필요 없다
- 동기화 시 상호배제 : mutex, spin lock, semaphore 등으로 상호 배제 한다.

# 2.4 프로그래머는 코루틴을 어떻게 이해해야 할까?

## 2.4.1 일반 함수

함수가 호출되면 순차적으로 실행

반환값을 가지고 호출지점으로 돌아감

## 2.4.2 일반 함수에서 코루틴으로

일반 함수와 형식의 차이는 없지만 일시 중지와 재개 기능이 있다.

자신의 실행 상태를 저장할 수 있기 때문에 코루틴이 반환된 후에도 계속 호출이 가능하며, 더군다나 마지막으로 일시 중지된 지점에서 다시 이어서 실행된다

```python
# python code 입니다
def func():
	print("a")
	yield
	print("b")
	yield
	print("c")
```

위 함수는 yield라는 명령어로 코루틴이 되었다.

```python
def A():
	co = funt()
	next(co)
	print("in funciton A")
	next(co)
```

위 함수를 실행하면

```python
a
in function A
b
```

## 2.4.3 직관적인 코루틴 설명

일반 함수 호출의 실행 흐름

![image](https://github.com/user-attachments/assets/e99b8a3c-e7a0-43f3-a4ce-43e2faa84ef5)

코루틴 호출의 실행 흐름

![image](https://github.com/user-attachments/assets/0e87b7b6-0d65-48dc-b392-152f8d6a7333)

## 2.4.4 함수는 그저 코루틴의 특별한 예에 불과하다

코루틴은 운영체제에서 스레드를 멈췄다가 다른 스레드의 스케줄링을 진행하는 것과 똑같다.

유의할점

- 타이머 인터럽트를 위한 작동방식이 없어 반드시 **일시중지 지점을 명시**해야 한다.
- OS 코루틴을 알지 못한다. 따라서 제어권은 사용자에게 있다.

## 2.4.5 코루틴의 역사

코루틴을 사용하기 좋은 곳 → 높은 성능과 동시성을 요구하는 분야

## 2.4.6 코루틴은 어떻게 구현될까?

스레드와 본질적으로 차이가 없음

코루틴은 일시 중지될 때 상태 정보를 반드시 기록한다. (힙 영역에 저장)

- CPU 레지스터 정보
- 함수 실행 시 상태 정보

이론적으로 메모리 공간이 충분하다면 코루틴 개수에 제한은 없으며 전환이나 스케줄링은 전적으로 사용자 상태에서 일어나기 때문에 OS가 개입할 필요가 없다.

또한, 프로그래머가 **동기 방식으로 비동기 프로그래밍**을 가능하게 한다.
