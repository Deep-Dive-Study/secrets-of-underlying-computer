# Ch2 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다
- 앞 챕터에선 인간이 이해할 수 있는 언어로 이루어진 문자열(코드)를 CPU가 이해할 수 있는 기계 명령어로 변환하는 과정을 알아보았음
- 이번 챕터에서는 **`프로그램이 실행되는 동안(런타임) 컴퓨터 내부에서는 어떤 일이 일어나는지`** 알아보자

## 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

### 2.1.1 모든 것은 CPU에서 시작된다
- CPU는 단순함. 오로지 두가지 행위만 할수 있음
  - 1. `메모리에서 명령어(instruction)를 하나 가져옵니다(dispatch)`
  - 2. `이 명령어를 실행한(execute) 후 다시 1.로 돌아갑니다. `

  ![CleanShot 2025-02-02 at 19 23 51@2x](https://github.com/user-attachments/assets/cc474e52-e871-44c3-855a-19dcad7eb0ed)

- 여기서 궁금한 점은 CPU는 어떤 기준 혹은 어떻게 메모리에서 명령어를 가져올수 있을까?
- 해당 질문에 대한 답은 `프로그램 카운터(PC, program counter)`라는 `레지스터(register)`에서 확인할 수 있음

  ![CleanShot 2025-02-02 at 19 24 15@2x](https://github.com/user-attachments/assets/3c95d5d0-0f0b-49c3-8aa0-c34af7ab671a)

- PC 레지스터에는 `메모리에 저장된 명령어 주소가 저장`되어 있음
  - 이를 통해 CPU가 `다음에 실행할 명령어`를 가져와서 CPU가 해당 동작을 수행하는 것임
  - 즉, 레지스터의 값은 개발자가 작성한 코드임(메모리의 데이터 영역에 저장되어 있음)
  
  ![CleanShot 2025-02-02 at 19 28 47@2x](https://github.com/user-attachments/assets/3eb3d06e-cf51-4775-83a0-08a0ead5c6e7)

  - 최초의 초기화 과정이 필요한데 이것이 개발자가 작성하는 `코드에 시작 지점(main 함수)`가 필요한 이유
    - 즉, 프로그램이 시작되면 먼저 main 함수에 대응하는 첫번째 기계 명령어를 찾고, 이어서 그 메모리 주소를 PC 레지스터에 기록함(레지스터 초기화 과정)  
  
- PC 레지스터가 저장하는 주소는 기본적으로 1씩 자동 증가함
- 다만, CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 `값을 동적으로 변경`함

## 2.1.2 CPU에서 운영 체제까지
- 앞선 과정(레지스터 초기화) 외에도 프로그램을 적재할 수 있는 적절한 메모리 영역을 찾고, CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)를 찾아 PC 레지스터를 설정하는 과정, 등의 작업이 추가적으로 더 필요함
- 또한, 이렇게 수동으로 프로그램을 관리하는 방식은 아래와 같은 단점이 있음
  - 한 번에 하나의 프로그램만 실행 가능
  - 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해서 외부 장치와의 연동을 해주어야함
  - 각종 표준 라이브러리(소켓 통신, 파일 I/O, 등)의 기능을 구현해야함
  - 별도로 프로그램과 사용자가 상호작용하기 위한 인터페이스를 구현해주어야 함  

- 이런 모든 과정을 지원해주는 프로그램이 **`운영체제(OS)`** 임
  - 운영 체제는 개발자가 더 이상 실행 파일을 수동으로 적재하거나 프로그램을 수동으로 유지 관리할 필요가 없어짐
  - 운영 체제는 실행 중인 프로그램을 관리해주어 한가지 일만 할 수 있는 CPU에게 적절한 일을 배분하여 여러가지 일을 동시에 실행할 수 있도록 함(멀티 태스킹)

- OS가 관리하기 위한 각각의 프로그램을 `프로세스(process)` 라고 함(현재 동작 중인 인스턴스)
  - 각 프로세스마다 현재 상태를 가지고 있는데 이를 `상황 정보(context)`라고 함
  - OS는 프로세스마다의 컨택스트를 저장하여 프로그램의 특정 작업이 전환된 후 다시 온전하게 실행할 수 있도록 함    

### 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다
- 각 프로세스는 OS로 부터 `프로세스 주소 공간(process address space)`라는 가상의 메모리 영역을 제공받음
  - 이를 통해 각 프로세스가 **표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 함**
  - 구성 요소
    - `코드 영역` : 코드를 컴파일하여 생성된 기계 명령어가 저장되는 영역
    - `데이터 영역` : 전역 변수 등이 저장되는 영역
    - `힙 영역` : malloc 함수가 요청을 반환한 메모리가 할당되는 영역
    - `스택 영역` : 함수의 실행 시간 스택 영역

  ![CleanShot 2025-02-02 at 19 47 16@2x](https://github.com/user-attachments/assets/9a5be103-6394-4770-8adc-4ae4964f6a69)

- 각 프로세스는 각각 독립적인 메모리 영역을 가지고 있기 때문에 프로세스간에 데이터를 주고 받기 위해서는 프로세스간 통신 과정이 필요함(`다중 프로세스 프로그래밍`)
  
  ![CleanShot 2025-02-02 at 19 50 20@2x](https://github.com/user-attachments/assets/ab1882d6-8156-4e2f-88b4-1564f16ce4e8)

### 2.1.4 프로세스에서 스레드로 진화
- 프로세스의 아쉬운점은 각 함수마다 순차적으로 실행이되어야 함
  - 실행 흐름에는 진입 포인트 정보가 있어야함
  - 순차적으로 실행되면 각 함수가 앞의 함수가 끝나야만 수행될 수 있기 때문에 서로 상관이 없더라도 대기를 해야함
  - 그렇다고 프로세스를 분리하기엔 프로세스간 통신과정이 복잡하고(오버해드 존재) 프로세스 생성 비용이 비쌈  

- 이러한 문제를 해결하기 위해 각 함수마다 동일한 실행 흐름과 프로세스 주소 공간을 공유하는 방식으로 `스레드(thread)`가 등장함
  - 하나의 프로세스 안에 존재하는 **여러 개의 실행 흐름이 존재하게 됨**
  - 이로써 더이상 프로세스 간 통신을 할 필요는 없어짐 

  ![CleanShot 2025-02-02 at 19 53 51@2x](https://github.com/user-attachments/assets/2e5490ab-80c8-4599-97b4-067119d2aca0)

- 하나의 프로세스에 진입 함수가 두개 이상 있을 수 있게됨. 즉, 하나의 프로세스에 속한 기계 명령어를 CPU 여러 개에서 동시에 실행 할 수 있게됨

- 다중 프로세스 프로그램과 다르게 **`스레드 간에는 프로세스 변수를 통해 함수 간의 값을 공유할 수 있음`**
  - 따라서, 프로세스 간의 전환보다 스레드 간의 전환이 더 가벼움(많은 정보를 다 가지고 있을 필요가 없기 때문에)
  - 스레드를 여러 개 생성하면 다중 코어를 충분히 이용할 수 있게 되어 CPU를 최대한 활용할 수 있게됨 (고성능/동시성 프로그래밍)

  ![CleanShot 2025-02-02 at 19 57 55@2x](https://github.com/user-attachments/assets/563ba00e-7b48-4c63-9548-883c9f0a1931)

- 다만, 스레드를 사용한 프로그래밍은 **`공유 리소스를 사용하기 때문에 큰 문제를 일으킬 가능성이 생김`**

### 2.1.5 다중 스레드와 메모리 구조
- 함수가 실행될 때 필요한 정보에는 `함수의 매개변수(parameter)`, `지역 변수(local variable)`, `반환 주소(return address)`, 등이 있음
  - 이러한 정보는 `스택 프레임에 저장됨`
  - 즉, 모든 함수는 실행 시에 자신만의 실행 시간 스택 프레임을 가짐

- 스레드 사용된 이후에는 각 실행 흐름별로 정보를 저장하기 위한 스택 영역이 별도로 필요함
- 즉, 모든 스레드는 각자 자긴만의 스택 영역을 가짐
  - 따라서, 스레드가 늘어날 수록 프로세스의 메모리 공간이 소모됨을 주의

  ![CleanShot 2025-02-02 at 20 12 57@2x](https://github.com/user-attachments/assets/204b6612-6a39-4ad6-9758-d3355b93c524)

### 2.1.6 스레드 활용 예
- 작업은 수명 주기 관점에서 보면 긴 작업과 짧은 작업으로 나누어 볼 수 있음

- 긴 작업의 경우 스레드와 프로세스가 수명 주기가 유사함. 따라서 특정 작업을 처리하기 위한 전용 스레드를 생성하는 것이 적합함

- 짧은 경우의 작업은 보통 `요청 당 스레드(thred-per-request)`라고 하며, 특정 작업을 수행하고 종료되는 방식을 의미

- 다만, 대량의 짧은 작업에서 이러한 방식은 단점이 있음(구현이 쉬운건 장점)  
  - 스레드의 생성과 종료에 많은 시간을 허비함
  - 스레드마다 각자 독립적인 스택 영역이 필요한데, 너무 많아지면 문제가 발생함
  - 스레드 수가 많아지면 스레드간 전환 비용이 증가함

- 이러한 문제를 해결하기 위해 **`스레드 풀(thread pool)`** 이라는 개념이 등장함

### 2.1.7 스레드 풀의 동작 방식
- **`스레드 풀`** 이란? 스레드 여러 개를 미리 생성해 두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청함
- 즉, **`스레드를 매번 생성/종료하지 않고 특정 개수를 유지하여 재사용하는 방식`**

  ![CleanShot 2025-02-02 at 20 21 41@2x](https://github.com/user-attachments/assets/b50edd7c-15cd-4e3f-bc0a-b3c8ebd7740f)

  - 큐(queue)를 사용해 구현
  - 생산자(producer)-소비자(consumer) 패턴 

- 스레드 풀의 스레드는 작업 대기열에서 블로킹 상태로 대기
- 대기열에 데이터가 추가되면 스레드가 깨어나고 처리 함수를 실행함

- 작업 대기열 큐는 여러 스레드 간에 공유되는 리소스이므로 동기화를 할때 **`상호 배제 문제(mutual exclusion in synchronization)`** 도 고려해야함

### 2.1.8 스레드 풀의 스레드 수
- 스레드 풀의 스레드가 너무 적으면 CPU를 최대한 활용할 수 없음. 반대로 너무 많다면, 시스템의 성능 저하, 메모리 과다 점유, 스레드 컨택스트 스위치 비용 증가로 인한 부담, 등 문제가 발생
- 즉, **너무 적지도 많지도 않게끔 적절한 수를 결정해야함**

- 이를 결정하기 위해서는 스레드가 처리하는 작업의 종류를 알아야함
  - 작업은 `CPU 집약적인 작업`, `입출력 집약적인 작업`으로 분류할 수 있음
- CPU 집약적인 작업인 경우 스레드 수와 CPU 코어 수가 동일한 것이 좋음
- 입출력 집약적인 작업은 약간 복잡한데 성능테스트 도구를 통해 WT(wait time)와 CT(computing time)을 측정해서 N개의 코어의 시스템에서 적절한 스레드를 구하는 공식을 적용해야함
  - 공식 : N x (1 + WT / CT)

## 2.2 스레드 간 공유되는 프로세스 리소스
- 프로세스는 운영 체제가 리소스를 할당하는 기본 단위
- 스레드는 스케줄링의 기본 단위
- 프로세스 리소스는 스레드 간에 공유 됨
- 이 절에서 알아볼 것른 스레드는 어떤 공유 리소스를 어떻게 공유하고 있는지

### 2.2.1 스레드 전용 리소스
- 상태 변화의 관점에서 보면 스레드는 사실 **`함수의 실행`** 임
  - 함수의 실행에는 항상 하나의 시작점이 존재하는데, 이 시작점이 바로 진입 함수임
  - CPU는 진입 함수에서 실행을 시작하여 하나의 실행 흐름을 생성하는데, 이 실행 흐름을 스레드라고 부르는 것

![CleanShot 2025-02-02 at 20 36 34@2x](https://github.com/user-attachments/assets/bd48eda5-52ab-4c15-8a88-a82727dd0ce3)

- 함수의 실행 시간 정보는 스택 영역을 구성하는 `스택 프레임`에 저장됨
  - 이때 스택 프레임 내에 함수의 반환 값, 매개변수, 지역 변수와 같은 정보가 저장됨
  
![CleanShot 2025-02-02 at 20 39 56@2x](https://github.com/user-attachments/assets/f6f11c5c-c0ac-443a-9ed3-b9a0c1172908)

- 스레드가 여러개인 경우 각 스레드마다 스택 영역이 존재함
  - 각 스택 영역에 있는 PC 레지스터, 스택 포인터, 등을 통틀어서 **`스레드 컨택스트(thread context)`** 라고 함 

- 스레드 영역을 제외한 나머지 영역들은 프로세스의 영역으로, 스레드 간에 공유하는 영역
  - 코드 영역, 데이터 영역, 힙 영역

### 2.2.2 코드 영역: 모든 함수를 스레드에 배치하여 실행할 수 있다
- 코드 영역에는 프로그래머가 작성한 코드(컴파일한 후에 생성된 기계 명령어)가 저장됨
  - 프로그램이 메모리에 적재(load)될때 코드 영역에 저장 

  ![CleanShot 2025-02-02 at 20 44 28@2x](https://github.com/user-attachments/assets/8f78b5c9-5a98-4aff-b9a9-2139005a8358)

- 해당 영역은 읽기 전용(read-only)의 영역이기 때문에, 스레드간에 공유해도 문제가 되지 않음

### 2.2.3 데이터 영역: 모든 스레드가 데이터 영역의 변수에 접근할 수 있다
- 전역 변수가 저장되는 곳
- 모든 스레드는 해당 영역에 접근이 가능한 상황

### 2.2.4 힙 영역: 포인터가 핵심이다
- malloc 함수와 new 예약어를 통해 요청하는 메모리가 이 영역에 할당됨
- 모든 스레드는 해당 변수 주소(포인터)만 알고 있다면 데이터에 접근 가능
  - 즉, 스레드간에 공유할 수 있는 데이터 

  ![CleanShot 2025-02-02 at 20 50 15@2x](https://github.com/user-attachments/assets/60291a18-e881-46d6-ad47-c092a2645751)

### 2.2.5 스택 영역: 공유 공간 내 전용 데이터
- 엄밀하게 따지만 스택 영역은 격리된 스레드 전용 공간은 아님
- 프로세스간은 가상 메모리 시스템에서 직접 접근할 수 없도록 분리를 보장함
  - 스레드는 그렇지 않기 때문에 하나의 스레드가 다른 스레드의 스택 프레임에서 포인터를 가져올 수 있다면 해당 스레드는 다른 스레드의 스택 영역을 직접 읽고 쓸 수 있음  
  
  ![CleanShot 2025-02-02 at 20 53 02@2x](https://github.com/user-attachments/assets/a320e5d2-fc00-4750-9562-76fec334b1ff)

- 이는 개발자 입장에서는 큰 버그로 동작하여 문제를 일으킬 수도 있음

### 2.2.6 동적 링크 라이브러리와 파일
- 동적 링크 라이브러리와 파일은 여유 공간에 할당됨
  - 이는 이러한 라이브러리는 프로세스 내 모든 스레드가 접근 가능하다는 의미 

  ![CleanShot 2025-02-02 at 20 55 13@2x](https://github.com/user-attachments/assets/528aa4e5-598e-4e26-9fe0-f0d2d3891126)

### 2.2.7 스레드 전용 저장소
- 각 스레드는 전용 저장소를 가지고 있음
- 이를 통해 각 스레드 간의 데이터를 공유할 때 복사해서 데이터를 가져와서 사용할 수 있음

  ![CleanShot 2025-02-02 at 20 58 03@2x](https://github.com/user-attachments/assets/9b682cb7-2570-4d77-bc6e-7395c574c412)

## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?
- 다중 스레드 코드를 작성하기 어려운 이유는 **`스레드 안전(thread safe)`** 을 고려해야하기 때문

### 2.3.1 자유와 제약
- 공유 리소스를 사용할 때는 반드시 그에 사응하는 제약이 필요하며, 특정 스레드가 다른 스레드의 공유 리소스 사용 순서를 방해하지 않는 한 스레드 안전을 달성할 수 있음
 
### 2.3.2 스레드 안전이란 무엇일까?
- 어떤 코드가 주어졌을 때, 그 코드가 **`스레드 몇 개에서 호출되든 이 스레드들이 어떤 순서로 호출되든 간에 상관 없이 올바른 결과가 나온다면`** , 이 코드를 **`스레드 안전`** 이라고 말함

- 먼저, 어떤 리소스가 공유 리소스인지 알아야 안전하기 위한 제약을 고려할 수 있음
  - 공유 리소스의 핵심은 여러 스레드에서 읽고 쓸 수 있어야 함 

  ![CleanShot 2025-02-02 at 21 03 54@2x](https://github.com/user-attachments/assets/e397edcb-ccb7-4b09-8de4-4fb2b83a5972)

### 2.3.3 스레드 전용 리소스와 공유 리소스
- 스레드간의 공유 리소스는 `힙 영역`과 `데이터 영역`임 
- 이런 공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며, 이 순서 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것임
  - 이를 위해, 각종 잠금(lock)이나 세마포어(semaphore) 같은 장치를 사용할 수 있음

- 이러한 규칙의 목적은 **`공유 리소스의 순서를 유지`** 하는 것임

### 2.3.5 스레드 전용 리소스와 함수 매개 변수
- 함수의 매개변수가 call by value로 값만 전달하면 문제가 없음
- 하지만, 포인터를 전달하면 포인터가 가르키는 주소는 힙 영역에 주소이기 때문에 안전하다고 할 수 없음

### 2.3.6 전역 변수 사용
- 전역 변수를 사용하더라도 읽기 전용으로 변수를 사용한다면(혹은 강제로 지정) 이는 문제가 되지 않음
- 만약 변경이 가능하다면, 전역 변수의 변경 과정은 반드시 잠금 등의 보호 또는 작업을 원자성 작업으로 설정해서 보호해야함

### 2.3.10 스레드 안전 코드는 어떻게 구현할까?
- 다중 스레드 프로그래밍을 할 때는 **`먼저 스레드 간에 어떤 리소스를 공유해야 하는지 고려`** 해야함
  - **공유 리소스가 어느 영역에 있던 최대한 공유하지 않는 편이 좋음** 

- 처리해야 할 작업이 스레드 사이에서 어떤 종류의 리소스를 공유해야한다면 반드시 코드의 스레드 안전에 주의를 기울여야함
- 스레드 안전을 달성하려면 먼저, 어떤 것이 스레드 전용 리소스인지, 아닌지를 파악해야함
- 공유 리소스를 사용해야한다면 아래와 같은 방식으로 스레드 안전하게 접근해야함
  - `스레드 전용 저장소 사용`
  - `읽기 전용`
  - `원자성 연산`
  - `동기화 시 상호 배제`
    - 뮤텍스, 세마포어, 등을 활용 

- 스레드 안전 구현은 스레드 전용 리소스와 스레드 공유 리소스를 중심으로 진행됩니다. 먼저 어떤 것이 스레드 전용 리소스고 어떤 것이 스레드 공유 리소스인지 파악하고, 이어 각 증상에 맞는 약을 처방하면 됩니다.

- 여기서 말한 스레드는 기본적으로 커널 스레드(kernel thread)를 의미함
  - 커널 스레드는 스레드의 생성, 스케줄링, 종료를 모두 운영체제가 수행
  - 즉, 프로그래머는 스레드가 어떻게 생성되고 스케줄링되는지 전혀 관여할 수 없다는 의미 

- 운영 체제에 의존하지 않는 상황에서 직접 스레드를 구현하여 사용하려면, 스레드 보다 가벼운 실행 흐름인 코루틴을 사용할 수 있음

## 2.4 프로그래머는 코루틴을 어떻게 이해해야할까?
- 최근 Go, Kotlin, 등 여러 언어에서 코루틴을 지원하고 있고, 고성능, 동시성을 요구하는 분야에서 자주 등장하고 있음

### 2.4.1 일반 함수
- 일반 함수는 보통 실행을 시작하고 코드의 마지막 줄까지 순차적으로 실행하고 반환됨
  - 그리고 보통 마지막까지 실행되어야 반환을 함
  - 재 호출시에는 처음부터 다시 시작함
 
  ![CleanShot 2025-02-02 at 22 22 51@2x](https://github.com/user-attachments/assets/b7b7e4a1-2a48-47f7-8a9c-b4e7be64f243)

### 2.4.2 일반 함수에서 코루틴으로
- 코루틴 또한 일반 함수와 형식적인 차이는 없으나, 스레드와 유사한 기능인 `일시 중지`와 `재개` 기능이 존재함
  
  ![CleanShot 2025-02-02 at 21 26 49@2x](https://github.com/user-attachments/assets/d4d19f62-797e-4a68-8b9b-9b7960febae7)

- 코루틴은 **`자신의 실행 상태를 저장할 수 있기 때문에 코루팅이 반환된 후에도 계속 호출이 가능하며, 마지막으로 일시 중지된 지점에서 다시 이어서 실행이 됨`**

### 2.4.3 직관적인 코루틴 설명
- **`코루틴의 실행 흐름`**

  ![CleanShot 2025-02-02 at 22 23 06@2x](https://github.com/user-attachments/assets/ab0aad79-18b7-4693-a581-ef5f3851b985)

- Func A 함수는 어느정도 실행되다가 코루틴을 실행 → 코루틴이 시작되면 첫번째 연결 시작 지점까지 실행하다가 일반 함수처럼 리턴
- Func A 함수는 이어서 실행되다가 다시 해당 코루틴을 실행 → 코루틴은 이때 첫번째 코드 부터가 아니고 연결 시작 지점부터 실행됨

### 2.4.4 함수는 그저 코루틴의 특별한 예에 불과하다
- 코루틴이 일시 중지될 때 실행 중인 상태를 저장했다가 저장되었던 상태로 돌아가 다시 시작하는 모습이 마치 운영체제가 스레드를 스케줄링하는 것과 똑같아 보임
- 즉, 사용자 모드(user mode)에서 실행되는 스레드라고 보면됨(**`사용자 상태 스레드`**)
  - 운영체제가 아닌 사용자가 직접 제어해야함 → 코루틴을 통해 개발자는 운영 체제와 유사한 역할을 할 수 있게됨

- 즉, **`사용자는 코루틴을 통해 언제 실행되고 중지될지에 대한 스케줄링의 제어권을 가지게 되어 함수를 제어할 수 있게됨`**

### 2.4.5 코루틴의 역사
- 코루틴은 새롭게 등장한 것이 아님
- 이전에는 스레드가 없었기 때문에 동시성 프로그램을 만들기 위해서는 어쩔수 없이 코루틴과 같은 기술을 사용할 수 밖에 없었음
- 운영체제와 스레드가 등장한 이후, 기본적으로 프로그램의 동시 실행을 지원하기 시작하면서 코루틴은 조용히 묻혀져 갔을 뿐임
- 다만, 최근 인터넷의 발달과 함께 고성능과 동시성을 요구하는 분야가 많아지면서 다시금 주목받기 시작하고 있음

### 2.4.6 코루틴은 어떻게 구현될까?
- **`코루틴의 구현은 사실 스레드의 구현과 본질적으로 차이가 없음`**
- 코루틴이 일시 중지되기 위해서는 **`일시 중지되는 시점에 상태 정보를 반드시 기록해야함`**
- 일반적인 상태 정보는 주로 함수의 스택 프레임에 저장됨(스레드를 위한 영역)
  - `CPU 레지스터 정보`
  - `함수 실행 시 상태 정보`  

- **`코루틴의 스택 프레임은 힙 영역에 저장됨`**

  ![CleanShot 2025-02-02 at 22 38 15@2x](https://github.com/user-attachments/assets/14ba33e5-9d0f-49ea-89f2-ff9862da0235)

- 이론적으로 메모리 공간이 충분하다면, 코루틴 개수에 제한은 없으며 코루틴 간 전환이나 스케줄링은 전적으로 사용자 상태에서 일어나기 때문에 운영체제가 개입할 필요가 없음

#### 코루틴이 중요한 이유(어떤 문제를 해결하는가?)
- 코루틴의 중요한 역할 중 하나는 바로 프로그래머가 **`동기 방식으로 비동기 프로그래밍을 가능하게 해줌`**

## 2.5 콜백 함수를 철저하게 이해한다.
- 함수를 마치 변수처럼 매개 변수로 주고 받고 싶은 요구 사항을 만족하기 위해 콜백 함수가 등장하게 됨
  - 매번 다른 함수(로직) 실행을 지원하던 상황에서는 프로그래머가 매번 이를 수행하기 위해 코드를 수정했어야함
 
### 2.5.3 비동기 콜백
- 호출 스레드가 콜백 함수 실행에 의존하지 않는 것을 비동기 콜백이라고 함

  ![CleanShot 2025-02-09 at 04 22 19@2x](https://github.com/user-attachments/assets/35266793-b64a-4725-98c8-4762661bbbf9)

### 2.5.4 비동기 콜백은 새로운 프로그래밍 사고방식으로 이어진다
- 함수의 동기 호출
  1. 함수를 호출하고 결과를 획득
  2. 획득한 결과 처리 

- 비동기 호출 프로그램밍에서는 특정 작업의 처리가 호출 스레드가 아닌 다른 작업 환경(스레드, 프로세스, 시스템)에서 처리될 수 있음
  - 이때, 특정 작업의 처리에서 동작해야하는 로직이 필요할 경우, 이를 전달하기 위해 콜백 함수가 사용됨

![CleanShot 2025-02-09 at 04 28 31@2x](https://github.com/user-attachments/assets/58f85095-fce8-4f65-a5d4-7f445b42e671)

### 2.5.5 콜백 함수의 정의
- 다른 코드에 매개변수로 전달되는 실행 가능한 코드

  ![CleanShot 2025-02-09 at 04 29 10@2x](https://github.com/user-attachments/assets/ae37dbd9-7ae4-4b8d-9de6-75e32899dd06)

- 콜백 함수를 전달한 측에서 호출하지 않고 전달 받은 측에서 호출함. 다만, 어떤 함수를 호출할지는 전달하는 측에서 작성해서 전달해야함
  - 작성할 책임만 있고, 호출할 책임은 없음
 
- 보통 이벤트가 발생하면 이를 처리할 수 있는 코드를 호출하기 위해 콜백 함수가 사용됨
  - 이벤트 처리 도구에 유용하며 이벤트 중심 프로그래밍에 적합

### 2.5.6 두 가지 콜백 유형
- `동기 콜백`
  - 블로킹 콜백이라고 부르며 주 프로그램과 콜백 함수가 동시에 실행될수 없으며 콜백 함수가 수행된 이후에 순차적으로 실행이 진행됨

    ![CleanShot 2025-02-09 at 04 36 48@2x](https://github.com/user-attachments/assets/5970bf0f-89e3-4fa7-b9c3-db6e7d1e207b)

- `비동기 콜백`
  - 지연 콜백이라고 부르며, 콜백 함수와 주 프로그램이 서로 다른 스레드 또는 프로세스에서 실행되며, 동시에 실행될 수 있음

  ![CleanShot 2025-02-09 at 04 40 56@2x](https://github.com/user-attachments/assets/0afcc21a-c6f2-4baf-aed3-c229975f1f78)

- 비동기 콜백은 다중 코어 리소스를 더 효율적으로 활용하며, 입출력이 많은 웹 서비스에서 높은 동시성 처리를 구현하기 적합함

### 2.5.7 비동기 콜백의 문제: 콜백 지옥
- 비동기 콜백의 작동 방식에 단점
  - 실행 시점을 알기 어렵고, 순차적인 흐름이 다소 복잡해지기 때문에 이해 하기 어려움
  - 또한, 비즈니스 로직이 복잡한 경우 콜백 지옥에 빠질 수 있음
    - 동기 호출 코드

      ![CleanShot 2025-02-09 at 04 44 36@2x](https://github.com/user-attachments/assets/39249c93-c62b-4b89-87c8-4effe8620922)
 
    - 비동기 호출 코드

      ![Google Chrome 2025-02-09 04 44 34](https://github.com/user-attachments/assets/3eca6100-9810-422f-bc0b-13dfed722ffe)

- 코루틴을 사용하면 이러한 비동기 콜백 코드의 효율성은 가져가면서 동기 콜백 코드의 단순성과 가독성을 함께 누릴 수 있음

## 2.6 동기와 비동기를 철저하게 이해한다
- 동기는 어떤 작업이 진행되는 해당 작업이 끝날때까지 기다리게 되는 방식
  - 블로킹 I/O 도 동기 방식
  - 즉, 동기 호출은 호출자와 수신자가 같은 스레드에서 실행중인지 여부와는 관계 없음 

  ![CleanShot 2025-02-09 at 04 48 28@2x](https://github.com/user-attachments/assets/06f4fa4e-663a-4e5c-8878-914edcbf8d30)

- 비동기는 어떤 작업이 진행되는 동안 해당 작업을 기다리지 않고 동시에 다른 작업을 진행하는 방식
  - 보통 파일 읽고 쓰기, 데이터 베이스 작업 등 시간이 다소 많이 걸리는 입출력 작업을 백그라운드 형태로 실행 

    ![CleanShot 2025-02-09 at 04 51 34@2x](https://github.com/user-attachments/assets/c50c8d71-33ca-4953-aff0-1e5b0acdcd68)

- 비동기 작업의 처리
  - 호출자가 실행 결과를 몰라도 되는 경우
    - 실행 결과를 처리할 수 있는 함수를 콜백 함수로 넘기면 됨 

      ![CleanShot 2025-02-09 at 04 53 40@2x](https://github.com/user-attachments/assets/e2c98491-71fa-4055-833f-cdbc6f141d69)
    
  - 호출자가 실행 결과를 알아야 하는 경우
    - 작업 완료를 알리는 신호나 메시지를 이용한 알림(notification) 작동 방식을 통해 실행 결과를 반환
    
      ![CleanShot 2025-02-09 at 04 54 51@2x](https://github.com/user-attachments/assets/ca71bc6a-686c-4ed9-b2cf-1b1662945441)


- 비동기 호출 방식이 무조건 동기 방식보다 더 효율적인 것은 아님. 문맥에 따라 적절하게 사용해야함

## 2.7 아 맞다! 블로킹과 논블로킹도 있다
- 동기, 비동기 이야기를 할때 항상 같이 나오는 대상이 블로킹과 논블로킹임(상당히 매우 헷갈리며, 많이 유사함)

- 동기란, 두 가지 대상이 강하게 결합된 것을 의미함
  - A 작업이 B 작업에 의존적   
  
    ![CleanShot 2025-02-09 at 05 02 13@2x](https://github.com/user-attachments/assets/e7ecaa99-736f-41d3-bdb3-b1e2af2b7fc7)

- 반대로 비동기란, 두 가지 대상이 강한 결합과 같은 제약이 없어 각자 자신의 작업을 수행할 수 있음을 의미
  - A 작업과 B 작업은 서로 독립적  
  
  ![CleanShot 2025-02-09 at 05 02 22@2x](https://github.com/user-attachments/assets/2bcff221-c26c-4a0a-b432-47c26fe3e1ab)

### 2.7.1 블로킹과 논블로킹
- 블로킹과 논블로킹은 프로그래밍에서 함수를 호출할때 주로 사용되는 용어

- 함수 A가 실행 중인 스레드나 프로세스를 일시 중지시킨다면 함수 B에 대한 호출 방식은 블로킹이라고 함
  - 일시 중지 시키지 않는 나머지 경우는 논블로킹 방식임

  ![CleanShot 2025-02-09 at 05 04 41@2x](https://github.com/user-attachments/assets/86549a12-e5e6-4be3-ac53-b66638c5ba26)

- 즉, 블로킹 호출의 핵심은 스레드 또는 프로세스가 일시 중지되는 것을 의미

### 2.7.2 블로킹의 핵심 문제: 입출력
- 일반적으로 블로킹은 대부분 I/O(입출력)과 관련이 있음
  - 디스크 I/O, 네트워크 I/O, 등
- 대부분의 I/O 작업은 CPU 처리에 비해 느린 경향이 있음
- 때문에, I/O 작업동안 스레드가 블로킹되는 상황에 CPU가 일을 하지 않고 대기하는 상황이 생김
  - 이는 매우 비효율적임. 제한된 스레드인 경우 스레드 대기 시간을 다른 요청들도 기다려야하는 상황(처리량 및 응답 속도 저하 문제 발생) 

### 2.7.3 논블로킹과 비동기 입출력
- 논블로킹 I/O는 호출 스레드를 일시 중지하는 대신 곧 바로 함수를 리턴함
  - 그 이후 호출 스레드는 자신의 작업을 계속 진행. 데이터 작업은 커널에서 수행(수행 완료시 알림 작동 방식을 사용)
  - 즉, 비동기 입출력이라고 보면됨

  ![CleanShot 2025-02-09 at 05 12 50@2x](https://github.com/user-attachments/assets/719d5952-1622-429c-a500-094b78a89c16)


### 2.7.5 동기와 블로킹
- 동기 호출은 반드시 블로킹이 아님
  - 동기적으로 호출했으나 바로 리턴되면 블로킹이라고 볼 수 없음

- 반면, 블로킹 호출은 모두 동기 호출이라고 볼 수 있음

### 2.7.6 비동기와 논블로킹
- 논블로킹이더라도 전체적으로 반드시 비동기라는 의미는 아님
  - 논블로킹 함수를 동기적으로 호출하는 경우(계속 확인하거나, 다른일을 안하는 등)

### 정리

![img](https://github.com/user-attachments/assets/418983e5-f74b-4596-8fa5-8fa477abb9e7)


## 2.8 높은 동시성과 고성능을 갖춘 서버 구현
- 어떻게 수백만명이 이용하는 서버를 구현할 수 있을까?

### 2.8.1 다중 프로세스
- 가장 간단한 형태의 병행 처리
- 리눅스의 fork을 통해 여러 자식 프로세스를 생성하여 요청을 처리하는 방식(process-per-connection)
  - 부모 프로세스가 사용자 요청을 받고, 자식 프로세스를 생성해 해당 사용자 요청을 처리한 후 종료되는 방식  
  
  ![CleanShot 2025-02-09 at 05 36 45@2x](https://github.com/user-attachments/assets/2d144a75-b541-40db-801b-0ff5ef6d86cc)

- 장점
  - 구현이 쉬움
  - 하나의 프로세스에서 문제가 발생해도 다른 프로세스에 영향을 주지 않음
  - 다중 코어 리소스를 활용 가능 

- 단점
  - 프로세스 간에 서로 통신이 필요한 경우, 복잡해지고 오버헤드가 듬
  - 프로세스를 요청 마다 생성하는 것은 부담이 상대적으로 큼(시스템에 부담을 줌) 

## 2.8.2 다중 스레드
- 각 요청에 대응하는 스레드를 생성하여 사용자 요청을 처리하는 방식(thread-per-connection)

  ![CleanShot 2025-02-09 at 05 41 40@2x](https://github.com/user-attachments/assets/1ac8f3f4-b1d7-4eaf-b464-26c45da4919b)


- 장점
  - 프로세스 주소 공간을 사용하기 때문에 별도의 통신이 필요하지 않음
  - 프로세스 보다 가볍고 생성과 종료에 드는 부담이 상대적으로 적음
  - 입출력 작업으로 인해 하나의 스레드가 블로킹 되어도 다른 스레드에는 영향을 주지 않음

- 단점
  - 스레드 끼리 서로 같은 주소를 공간을 사용하는 영역(공유 리소스)이 있기 때문에 스레드 안전 문제를 고려해야함
  - 부담이 프로세스에 비해 덜할 뿐, 아에 없지는 않음(메모리 소비, 스위칭 비용, 등)
  - 하나의 스레드에서 문제가 생겨 강제 종료되는 경우에는 다른 모든 스레드와 프로세스가 종료될 수 있음

### 2.8.3 이벤트 루프(순환)과 이벤트 구동
- 이벤트 기반의 동시성을 이용한 `이벤트 기반 프로그래밍`
  - 최근? 에 사용자가 많아지면서 높은 동시성 처리를 위한 고성능 서버에 대한 수요가 늘어나면서 각광 받고 있음

- 이벤트 프로그래밍의 두가지 구성요소
  - 이벤트
    - 서버 입장에서의 이벤트는 대부분 입출력에 관계된 것 
  
  - 이벤트를 처리하는 함수
    - 보통 해당 함수를 이벤트 핸들러라고 함  

- 이벤트 프로그래밍의 동작
  - 이벤트를 기다리다가, 이벤트가 도착하면 이벤트 유형을 확인하여 적절한 이벤트 핸들러를 호출

- 서버 입장에서는 이벤트는 사용자의 요청이며, 서버는 이벤트를 계속 반복적으로 수신하고 처리해야함
  - 해당 반복을 이벤트 루프라고 함 

  ![Google Chrome 2025-02-09 05 53 19](https://github.com/user-attachments/assets/a9c14798-83cd-4811-9fc4-3de9612a6eab)

#### 해결해야할 문제
- 이벤트 소스에 관한 문제로, 하나의 함수로 어떻게 여러 이벤트를 수신할 수 있을지?
- 이벤트를 처리하는 핸들러 함수가 반드시 이벤트 순환과 동일한 스레드에서 실행되어야 하는지?

### 2.8.4 첫번째 문제: 이벤트 소스와 입출력 다중화
- 리눅스의 입출력 다중화 기술인 epoll을 사용
  - 소켓을 감시하고 있다가 데이터가 들어오면 알려줌 
- epoll은 이벤트 순환의 엔진이 되어 지속적으로 다양한 이벤트를 제공함

  ![CleanShot 2025-02-09 at 05 58 40@2x](https://github.com/user-attachments/assets/63c79bef-97e2-4148-9bd8-08533298ffc9)


### 2.8.5 두번째 문제: 이벤트 순환과 다중 스레드
- 이벤트 핸들러가 입출력 작업이 없고, 처리 함수가 간단해서 소요 시간이 매우 짧은 경우에는 동일한 스레드에서 실행해도 문제가 없음

  ![CleanShot 2025-02-09 at 06 01 30@2x](https://github.com/user-attachments/assets/e5bac36d-dcc6-4f3a-bdd2-498d5b64da98)

- 반대로, 입출력 작업이 많고, 처리가 오래 걸리는 경우 별도의 스레드에서 동작해야함
  - 하나의 스레드밖에 없는데 블로킹되는 경우, 다음 요청을 처리하지 못하기 때문에 전체적인 이벤트 처리가 느려짐
  - 해당 방식을 반응자 패턴(reactor pattern)이라고 함

  ![CleanShot 2025-02-09 at 06 06 30@2x](https://github.com/user-attachments/assets/a5270921-233d-45c9-b5d0-db2e614fbf6e)

### 2.8.9 코루틴: 동기 방식의 비동기 프로그래밍
- 코루틴을 사용하면, 코루틴이 일시 중지되더라도 작업자 스레드가 블로킹 되지 않음
  - 코루틴이 일시 중지되면 작업자 스레드는 준비 완료된 다른 코루틴을 실행하기 위해 전환됨
  - 일시 중지된 코루틴은 응답이 돌아오면 준비 상태가되어 스케줄링 차례가 돌아오길 기다림

    ![CleanShot 2025-02-09 at 06 11 42@2x](https://github.com/user-attachments/assets/231338f6-faab-4281-97a4-8c9b66f5ffd4)

- 코루틴의 도움으로 프로그래밍은 동기 방식으로 하면서 비동기 실행과 같은 효과를 얻을 수 있음

  ![CleanShot 2025-02-09 at 06 13 06@2x](https://github.com/user-attachments/assets/9104f8d7-acd3-4030-8231-11ebad70fe3f)

  - 이벤트 순환은 요청을 받은 후 우리가 구현한 handler 함수를 코루틴에 담아 스케줄링과 실행을 위해 각 작업자 스레드에 배포함.
  - 작업자 스레드는 코루틴을 획득한 후 진입 함수인 handler 함수를 실행함
  - 어떤 코루틴이 외부 API 요청으로 능동적으로 CPU의 제어권을 반환하면 작업자 스레드는 준비 상태인 다른 코루틴을 실행함

### 2.9.9 CPU, 스레드, 코루틴
- CPU, 스레드, 코루틴의 관계
  - 각 다른 계층에서 작업을 추상화하고 있음

  ![CleanShot 2025-02-09 at 06 16 52@2x](https://github.com/user-attachments/assets/4fcca4f7-ef28-4a83-bb1a-c856ef7feb39)

- 코루틴은 본질적으로 사용자 상태에서 스레드의 CPU 시간을 2차 할당하는 것
  - 즉, 사용자 상태(모드)에서 작업을 스케줄링하여 스레드에 할당하기 위한 추상화된 것 

  ![CleanShot 2025-02-09 at 06 17 39@2x](https://github.com/user-attachments/assets/5349017b-f10a-4508-9035-6648352193d3)


## 2.9 컴퓨터 시스템 여행: 데이터, 코드, 콜백, 클로저에서 컨테이너, 가상 머신까지

### 2.9.1 코드, 데이터, 변수, 포인터
- 고급 프로그래밍 언어 이전에는 모든 프로그램을 기계 명령어로 작성했었음
- 하지만, 일부 명령어가 항상 반복됨을 인지하고, 이를 묶고 별칭을 붙인 **`함수`** 를 만들게 됨
- 명령어 뿐만 아니라 데이터에도 별칭을 지칭할 수 있음을 깨닫고, **`변수`** 또한 만들어 내게 됨
  - 동일 데이터를 여러 변수에서 참조하기 위해 포인터라는 개념도 등장함

### 2.9.2 콜백 함수와 클로저
- 여러개 변수가 데이터 뿐만 아니라 동일한 코드를 참조하기 위해 함수 또한 데이터 처럼 취급할 수 있음. 이러한 함수를 `일급 객체 함수` 라고 함
  - 코드를 할당, 사용, 매개변수로 전달, 반환 값으로 사용, 등 일반 변수 처럼 사용할 수 있음 

- 함수가 다른 함수에 매개 변수로 전달될 때, 해당 함수를 `콜백 함수`라고 부름
- 콜백 함수를 일부 데이터와 한데 묶어서 변수 처럼 취급하기 위해 `클로저(closure)`가 만들어짐

### 2.9.3 컨테이너와 가상 머신 기술
- 어떤 함수가 CPU를 능동적으로 일시 중지하고 다음에 함수가 다시 호출될때 앞에서 중단점 지점에서 계속 실행하는 것이 가능할 때, 그 함수는 코루틴에 해당함
- 반면에, 함수의 일시 중지와 재개가 커널 상태에서 구현되는 경우에는 `스레드`라고 부름
- 스레드에 주소 공간처럼 종속된 실행 시 리소스를 결합한 것이 바로 `프로세스`임
- 운영체제를 가상화하여 프로세스가 독점적으로 자원을 사용하는 것처럼 동작할 수 있도록 하는 `가상 머신`이 있음
- 프로그램이 구성, 라이브러리 처럼 의존하는 실행 환경과 함께 묶인 것을 `컨테이너` 라고함

