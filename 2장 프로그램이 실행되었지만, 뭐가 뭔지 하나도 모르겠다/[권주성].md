# Ch2 프로그램이 실행되었지만, 뭐가 뭔지 하나도 모르겠다
- 앞 챕터에선 인간이 이해할 수 있는 언어로 이루어진 문자열(코드)를 CPU가 이해할 수 있는 기계 명령어로 변환하는 과정을 알아보았음
- 이번 챕터에서는 **`프로그램이 실행되는 동안(런타임) 컴퓨터 내부에서는 어떤 일이 일어나는지`** 알아보자

## 2.1 운영체제, 프로세스, 스레드의 근본 이해하기

### 2.1.1 모든 것은 CPU에서 시작된다
- CPU는 단순함. 오로지 두가지 행위만 할수 있음
  - 1. `메모리에서 명령어(instruction)를 하나 가져옵니다(dispatch)`
  - 2. `이 명령어를 실행한(execute) 후 다시 1.로 돌아갑니다. `

  ![CleanShot 2025-02-02 at 19 23 51@2x](https://github.com/user-attachments/assets/cc474e52-e871-44c3-855a-19dcad7eb0ed)

- 여기서 궁금한 점은 CPU는 어떤 기준 혹은 어떻게 메모리에서 명령어를 가져올수 있을까?
- 해당 질문에 대한 답은 `프로그램 카운터(PC, program counter)`라는 `레지스터(register)`에서 확인할 수 있음

  ![CleanShot 2025-02-02 at 19 24 15@2x](https://github.com/user-attachments/assets/3c95d5d0-0f0b-49c3-8aa0-c34af7ab671a)

- PC 레지스터에는 `메모리에 저장된 명령어 주소가 저장`되어 있음
  - 이를 통해 CPU가 `다음에 실행할 명령어`를 가져와서 CPU가 해당 동작을 수행하는 것임
  - 즉, 레지스터의 값은 개발자가 작성한 코드임(메모리의 데이터 영역에 저장되어 있음)
  
  ![CleanShot 2025-02-02 at 19 28 47@2x](https://github.com/user-attachments/assets/3eb3d06e-cf51-4775-83a0-08a0ead5c6e7)

  - 최초의 초기화 과정이 필요한데 이것이 개발자가 작성하는 `코드에 시작 지점(main 함수)`가 필요한 이유
    - 즉, 프로그램이 시작되면 먼저 main 함수에 대응하는 첫번째 기계 명령어를 찾고, 이어서 그 메모리 주소를 PC 레지스터에 기록함(레지스터 초기화 과정)  
  
- PC 레지스터가 저장하는 주소는 기본적으로 1씩 자동 증가함
- 다만, CPU는 연산 결과 또는 명령어에서 지정한 점프할 대상 주소에 따라 `값을 동적으로 변경`함

## 2.1.2 CPU에서 운영 체제까지
- 앞선 과정(레지스터 초기화) 외에도 프로그램을 적재할 수 있는 적절한 메모리 영역을 찾고, CPU 레지스터를 초기화하고 함수의 진입 포인트(entry point)를 찾아 PC 레지스터를 설정하는 과정, 등의 작업이 추가적으로 더 필요함
- 또한, 이렇게 수동으로 프로그램을 관리하는 방식은 아래와 같은 단점이 있음
  - 한 번에 하나의 프로그램만 실행 가능
  - 모든 프로그램은 사용할 하드웨어를 직접 특정 드라이버와 연결해서 외부 장치와의 연동을 해주어야함
  - 각종 표준 라이브러리(소켓 통신, 파일 I/O, 등)의 기능을 구현해야함
  - 별도로 프로그램과 사용자가 상호작용하기 위한 인터페이스를 구현해주어야 함  

- 이런 모든 과정을 지원해주는 프로그램이 **`운영체제(OS)`** 임
  - 운영 체제는 개발자가 더 이상 실행 파일을 수동으로 적재하거나 프로그램을 수동으로 유지 관리할 필요가 없어짐
  - 운영 체제는 실행 중인 프로그램을 관리해주어 한가지 일만 할 수 있는 CPU에게 적절한 일을 배분하여 여러가지 일을 동시에 실행할 수 있도록 함(멀티 태스킹)

- OS가 관리하기 위한 각각의 프로그램을 `프로세스(process)` 라고 함(현재 동작 중인 인스턴스)
  - 각 프로세스마다 현재 상태를 가지고 있는데 이를 `상황 정보(context)`라고 함
  - OS는 프로세스마다의 컨택스트를 저장하여 프로그램의 특정 작업이 전환된 후 다시 온전하게 실행할 수 있도록 함    

### 2.1.3 프로세스는 매우 훌륭하지만, 아직 불편하다
- 각 프로세스는 OS로 부터 `프로세스 주소 공간(process address space)`라는 가상의 메모리 영역을 제공받음
  - 이를 통해 각 프로세스가 **표준적인 메모리 크기를 독점적으로 사용하는 것처럼 보이게 함**
  - 구성 요소
    - `코드 영역` : 코드를 컴파일하여 생성된 기계 명령어가 저장되는 영역
    - `데이터 영역` : 전역 변수 등이 저장되는 영역
    - `힙 영역` : malloc 함수가 요청을 반환한 메모리가 할당되는 영역
    - `스택 영역` : 함수의 실행 시간 스택 영역

  ![CleanShot 2025-02-02 at 19 47 16@2x](https://github.com/user-attachments/assets/9a5be103-6394-4770-8adc-4ae4964f6a69)

- 각 프로세스는 각각 독립적인 메모리 영역을 가지고 있기 때문에 프로세스간에 데이터를 주고 받기 위해서는 프로세스간 통신 과정이 필요함(`다중 프로세스 프로그래밍`)
  
  ![CleanShot 2025-02-02 at 19 50 20@2x](https://github.com/user-attachments/assets/ab1882d6-8156-4e2f-88b4-1564f16ce4e8)

### 2.1.4 프로세스에서 스레드로 진화
- 프로세스의 아쉬운점은 각 함수마다 순차적으로 실행이되어야 함
  - 실행 흐름에는 진입 포인트 정보가 있어야함
  - 순차적으로 실행되면 각 함수가 앞의 함수가 끝나야만 수행될 수 있기 때문에 서로 상관이 없더라도 대기를 해야함
  - 그렇다고 프로세스를 분리하기엔 프로세스간 통신과정이 복잡하고(오버해드 존재) 프로세스 생성 비용이 비쌈  

- 이러한 문제를 해결하기 위해 각 함수마다 동일한 실행 흐름과 프로세스 주소 공간을 공유하는 방식으로 `스레드(thread)`가 등장함
  - 하나의 프로세스 안에 존재하는 **여러 개의 실행 흐름이 존재하게 됨**
  - 이로써 더이상 프로세스 간 통신을 할 필요는 없어짐 

  ![CleanShot 2025-02-02 at 19 53 51@2x](https://github.com/user-attachments/assets/2e5490ab-80c8-4599-97b4-067119d2aca0)

- 하나의 프로세스에 진입 함수가 두개 이상 있을 수 있게됨. 즉, 하나의 프로세스에 속한 기계 명령어를 CPU 여러 개에서 동시에 실행 할 수 있게됨

- 다중 프로세스 프로그램과 다르게 **`스레드 간에는 프로세스 변수를 통해 함수 간의 값을 공유할 수 있음`**
  - 따라서, 프로세스 간의 전환보다 스레드 간의 전환이 더 가벼움(많은 정보를 다 가지고 있을 필요가 없기 때문에)
  - 스레드를 여러 개 생성하면 다중 코어를 충분히 이용할 수 있게 되어 CPU를 최대한 활용할 수 있게됨 (고성능/동시성 프로그래밍)

  ![CleanShot 2025-02-02 at 19 57 55@2x](https://github.com/user-attachments/assets/563ba00e-7b48-4c63-9548-883c9f0a1931)

- 다만, 스레드를 사용한 프로그래밍은 **`공유 리소스를 사용하기 때문에 큰 문제를 일으킬 가능성이 생김`**

### 2.1.5 다중 스레드와 메모리 구조
- 함수가 실행될 때 필요한 정보에는 `함수의 매개변수(parameter)`, `지역 변수(local variable)`, `반환 주소(return address)`, 등이 있음
  - 이러한 정보는 `스택 프레임에 저장됨`
  - 즉, 모든 함수는 실행 시에 자신만의 실행 시간 스택 프레임을 가짐

- 스레드 사용된 이후에는 각 실행 흐름별로 정보를 저장하기 위한 스택 영역이 별도로 필요함
- 즉, 모든 스레드는 각자 자긴만의 스택 영역을 가짐
  - 따라서, 스레드가 늘어날 수록 프로세스의 메모리 공간이 소모됨을 주의

  ![CleanShot 2025-02-02 at 20 12 57@2x](https://github.com/user-attachments/assets/204b6612-6a39-4ad6-9758-d3355b93c524)

### 2.1.6 스레드 활용 예
- 작업은 수명 주기 관점에서 보면 긴 작업과 짧은 작업으로 나누어 볼 수 있음

- 긴 작업의 경우 스레드와 프로세스가 수명 주기가 유사함. 따라서 특정 작업을 처리하기 위한 전용 스레드를 생성하는 것이 적합함

- 짧은 경우의 작업은 보통 `요청 당 스레드(thred-per-request)`라고 하며, 특정 작업을 수행하고 종료되는 방식을 의미

- 다만, 대량의 짧은 작업에서 이러한 방식은 단점이 있음(구현이 쉬운건 장점)  
  - 스레드의 생성과 종료에 많은 시간을 허비함
  - 스레드마다 각자 독립적인 스택 영역이 필요한데, 너무 많아지면 문제가 발생함
  - 스레드 수가 많아지면 스레드간 전환 비용이 증가함

- 이러한 문제를 해결하기 위해 **`스레드 풀(thread pool)`** 이라는 개념이 등장함

### 2.1.7 스레드 풀의 동작 방식
- **`스레드 풀`** 이란? 스레드 여러 개를 미리 생성해 두고, 스레드가 처리할 작업이 생기면 해당 스레드에 처리를 요청함
- 즉, **`스레드를 매번 생성/종료하지 않고 특정 개수를 유지하여 재사용하는 방식`**

  ![CleanShot 2025-02-02 at 20 21 41@2x](https://github.com/user-attachments/assets/b50edd7c-15cd-4e3f-bc0a-b3c8ebd7740f)

  - 큐(queue)를 사용해 구현
  - 생산자(producer)-소비자(consumer) 패턴 

- 스레드 풀의 스레드는 작업 대기열에서 블로킹 상태로 대기
- 대기열에 데이터가 추가되면 스레드가 깨어나고 처리 함수를 실행함

- 작업 대기열 큐는 여러 스레드 간에 공유되는 리소스이므로 동기화를 할때 **`상호 배제 문제(mutual exclusion in synchronization)`** 도 고려해야함

### 2.1.8 스레드 풀의 스레드 수
- 스레드 풀의 스레드가 너무 적으면 CPU를 최대한 활용할 수 없음. 반대로 너무 많다면, 시스템의 성능 저하, 메모리 과다 점유, 스레드 컨택스트 스위치 비용 증가로 인한 부담, 등 문제가 발생
- 즉, **너무 적지도 많지도 않게끔 적절한 수를 결정해야함**

- 이를 결정하기 위해서는 스레드가 처리하는 작업의 종류를 알아야함
  - 작업은 `CPU 집약적인 작업`, `입출력 집약적인 작업`으로 분류할 수 있음
- CPU 집약적인 작업인 경우 스레드 수와 CPU 코어 수가 동일한 것이 좋음
- 입출력 집약적인 작업은 약간 복잡한데 성능테스트 도구를 통해 WT(wait time)와 CT(computing time)을 측정해서 N개의 코어의 시스템에서 적절한 스레드를 구하는 공식을 적용해야함
  - 공식 : N x (1 + WT / CT)

## 2.2 스레드 간 공유되는 프로세스 리소스
- 프로세스는 운영 체제가 리소스를 할당하는 기본 단위
- 스레드는 스케줄링의 기본 단위
- 프로세스 리소스는 스레드 간에 공유 됨
- 이 절에서 알아볼 것른 스레드는 어떤 공유 리소스를 어떻게 공유하고 있는지

### 2.2.1 스레드 전용 리소스
- 상태 변화의 관점에서 보면 스레드는 사실 **`함수의 실행`** 임
  - 함수의 실행에는 항상 하나의 시작점이 존재하는데, 이 시작점이 바로 진입 함수임
  - CPU는 진입 함수에서 실행을 시작하여 하나의 실행 흐름을 생성하는데, 이 실행 흐름을 스레드라고 부르는 것

![CleanShot 2025-02-02 at 20 36 34@2x](https://github.com/user-attachments/assets/bd48eda5-52ab-4c15-8a88-a82727dd0ce3)

- 함수의 실행 시간 정보는 스택 영역을 구성하는 `스택 프레임`에 저장됨
  - 이때 스택 프레임 내에 함수의 반환 값, 매개변수, 지역 변수와 같은 정보가 저장됨
  
![CleanShot 2025-02-02 at 20 39 56@2x](https://github.com/user-attachments/assets/f6f11c5c-c0ac-443a-9ed3-b9a0c1172908)

- 스레드가 여러개인 경우 각 스레드마다 스택 영역이 존재함
  - 각 스택 영역에 있는 PC 레지스터, 스택 포인터, 등을 통틀어서 **`스레드 컨택스트(thread context)`** 라고 함 

- 스레드 영역을 제외한 나머지 영역들은 프로세스의 영역으로, 스레드 간에 공유하는 영역
  - 코드 영역, 데이터 영역, 힙 영역

### 2.2.2 코드 영역: 모든 함수를 스레드에 배치하여 실행할 수 있다
- 코드 영역에는 프로그래머가 작성한 코드(컴파일한 후에 생성된 기계 명령어)가 저장됨
  - 프로그램이 메모리에 적재(load)될때 코드 영역에 저장 

  ![CleanShot 2025-02-02 at 20 44 28@2x](https://github.com/user-attachments/assets/8f78b5c9-5a98-4aff-b9a9-2139005a8358)

- 해당 영역은 읽기 전용(read-only)의 영역이기 때문에, 스레드간에 공유해도 문제가 되지 않음

### 2.2.3 데이터 영역: 모든 스레드가 데이터 영역의 변수에 접근할 수 있다
- 전역 변수가 저장되는 곳
- 모든 스레드는 해당 영역에 접근이 가능한 상황

### 2.2.4 힙 영역: 포인터가 핵심이다
- malloc 함수와 new 예약어를 통해 요청하는 메모리가 이 영역에 할당됨
- 모든 스레드는 해당 변수 주소(포인터)만 알고 있다면 데이터에 접근 가능
  - 즉, 스레드간에 공유할 수 있는 데이터 

  ![CleanShot 2025-02-02 at 20 50 15@2x](https://github.com/user-attachments/assets/60291a18-e881-46d6-ad47-c092a2645751)

### 2.2.5 스택 영역: 공유 공간 내 전용 데이터
- 엄밀하게 따지만 스택 영역은 격리된 스레드 전용 공간은 아님
- 프로세스간은 가상 메모리 시스템에서 직접 접근할 수 없도록 분리를 보장함
  - 스레드는 그렇지 않기 때문에 하나의 스레드가 다른 스레드의 스택 프레임에서 포인터를 가져올 수 있다면 해당 스레드는 다른 스레드의 스택 영역을 직접 읽고 쓸 수 있음  
  
  ![CleanShot 2025-02-02 at 20 53 02@2x](https://github.com/user-attachments/assets/a320e5d2-fc00-4750-9562-76fec334b1ff)

- 이는 개발자 입장에서는 큰 버그로 동작하여 문제를 일으킬 수도 있음

### 2.2.6 동적 링크 라이브러리와 파일
- 동적 링크 라이브러리와 파일은 여유 공간에 할당됨
  - 이는 이러한 라이브러리는 프로세스 내 모든 스레드가 접근 가능하다는 의미 

  ![CleanShot 2025-02-02 at 20 55 13@2x](https://github.com/user-attachments/assets/528aa4e5-598e-4e26-9fe0-f0d2d3891126)

### 2.2.7 스레드 전용 저장소
- 각 스레드는 전용 저장소를 가지고 있음
- 이를 통해 각 스레드 간의 데이터를 공유할 때 복사해서 데이터를 가져와서 사용할 수 있음

  ![CleanShot 2025-02-02 at 20 58 03@2x](https://github.com/user-attachments/assets/9b682cb7-2570-4d77-bc6e-7395c574c412)

## 2.3 스레드 안전 코드는 도대체 어떻게 작성해야 할까?
- 다중 스레드 코드를 작성하기 어려운 이유는 **`스레드 안전(thread safe)`** 을 고려해야하기 때문

### 2.3.1 자유와 제약
- 공유 리소스를 사용할 때는 반드시 그에 사응하는 제약이 필요하며, 특정 스레드가 다른 스레드의 공유 리소스 사용 순서를 방해하지 않는 한 스레드 안전을 달성할 수 있음
 
### 2.3.2 스레드 안전이란 무엇일까?
- 어떤 코드가 주어졌을 때, 그 코드가 **`스레드 몇 개에서 호출되든 이 스레드들이 어떤 순서로 호출되든 간에 상관 없이 올바른 결과가 나온다면`** , 이 코드를 **`스레드 안전`** 이라고 말함

- 먼저, 어떤 리소스가 공유 리소스인지 알아야 안전하기 위한 제약을 고려할 수 있음
  - 공유 리소스의 핵심은 여러 스레드에서 읽고 쓸 수 있어야 함 

  ![CleanShot 2025-02-02 at 21 03 54@2x](https://github.com/user-attachments/assets/e397edcb-ccb7-4b09-8de4-4fb2b83a5972)

### 2.3.3 스레드 전용 리소스와 공유 리소스
- 스레드간의 공유 리소스는 `힙 영역`과 `데이터 영역`임 
- 이런 공유 리소스를 사용하는 스레드는 반드시 순서를 따라야 하며, 이 순서 핵심은 공유 리소스를 사용하는 작업이 다른 스레드를 방해할 수 없다는 것임
  - 이를 위해, 각종 잠금(lock)이나 세마포어(semaphore) 같은 장치를 사용할 수 있음

- 이러한 규칙의 목적은 **`공유 리소스의 순서를 유지`** 하는 것임

### 2.3.5 스레드 전용 리소스와 함수 매개 변수
- 함수의 매개변수가 call by value로 값만 전달하면 문제가 없음
- 하지만, 포인터를 전달하면 포인터가 가르키는 주소는 힙 영역에 주소이기 때문에 안전하다고 할 수 없음

### 2.3.6 전역 변수 사용
- 전역 변수를 사용하더라도 읽기 전용으로 변수를 사용한다면(혹은 강제로 지정) 이는 문제가 되지 않음
- 만약 변경이 가능하다면, 전역 변수의 변경 과정은 반드시 잠금 등의 보호 또는 작업을 원자성 작업으로 설정해서 보호해야함

### 2.3.10 스레드 안전 코드는 어떻게 구현할까?
- 다중 스레드 프로그래밍을 할 때는 **`먼저 스레드 간에 어떤 리소스를 공유해야 하는지 고려`** 해야함
  - **공유 리소스가 어느 영역에 있던 최대한 공유하지 않는 편이 좋음** 

- 처리해야 할 작업이 스레드 사이에서 어떤 종류의 리소스를 공유해야한다면 반드시 코드의 스레드 안전에 주의를 기울여야함
- 스레드 안전을 달성하려면 먼저, 어떤 것이 스레드 전용 리소스인지, 아닌지를 파악해야함
- 공유 리소스를 사용해야한다면 아래와 같은 방식으로 스레드 안전하게 접근해야함
  - `스레드 전용 저장소 사용`
  - `읽기 전용`
  - `원자성 연산`
  - `동기화 시 상호 배제`
    - 뮤텍스, 세마포어, 등을 활용 

- 스레드 안전 구현은 스레드 전용 리소스와 스레드 공유 리소스를 중심으로 진행됩니다. 먼저 어떤 것이 스레드 전용 리소스고 어떤 것이 스레드 공유 리소스인지 파악하고, 이어 각 증상에 맞는 약을 처방하면 됩니다.

- 여기서 말한 스레드는 기본적으로 커널 스레드(kernel thread)를 의미함
  - 커널 스레드는 스레드의 생성, 스케줄링, 종료를 모두 운영체제가 수행
  - 즉, 프로그래머는 스레드가 어떻게 생성되고 스케줄링되는지 전혀 관여할 수 없다는 의미 

- 운영 체제에 의존하지 않는 상황에서 직접 스레드를 구현하여 사용하려면, 스레드 보다 가벼운 실행 흐름인 코루틴을 사용할 수 있음

## 2.4 프로그래머는 코루틴을 어떻게 이해해야할까?
- 최근 Go, Kotlin, 등 여러 언어에서 코루틴을 지원하고 있고, 고성능, 동시성을 요구하는 분야에서 자주 등장하고 있음

### 2.4.1 일반 함수
- 일반 함수는 보통 실행을 시작하고 코드의 마지막 줄까지 순차적으로 실행하고 반환됨
  - 그리고 보통 마지막까지 실행되어야 반환을 함
  - 재 호출시에는 처음부터 다시 시작함
 
  ![CleanShot 2025-02-02 at 22 22 51@2x](https://github.com/user-attachments/assets/b7b7e4a1-2a48-47f7-8a9c-b4e7be64f243)

### 2.4.2 일반 함수에서 코루틴으로
- 코루틴 또한 일반 함수와 형식적인 차이는 없으나, 스레드와 유사한 기능인 `일시 중지`와 `재개` 기능이 존재함
  
  ![CleanShot 2025-02-02 at 21 26 49@2x](https://github.com/user-attachments/assets/d4d19f62-797e-4a68-8b9b-9b7960febae7)

- 코루틴은 **`자신의 실행 상태를 저장할 수 있기 때문에 코루팅이 반환된 후에도 계속 호출이 가능하며, 마지막으로 일시 중지된 지점에서 다시 이어서 실행이 됨`**

### 2.4.3 직관적인 코루틴 설명
- **`코루틴의 실행 흐름`**

  ![CleanShot 2025-02-02 at 22 23 06@2x](https://github.com/user-attachments/assets/ab0aad79-18b7-4693-a581-ef5f3851b985)

- Func A 함수는 어느정도 실행되다가 코루틴을 실행 → 코루틴이 시작되면 첫번째 연결 시작 지점까지 실행하다가 일반 함수처럼 리턴
- Func A 함수는 이어서 실행되다가 다시 해당 코루틴을 실행 → 코루틴은 이때 첫번째 코드 부터가 아니고 연결 시작 지점부터 실행됨

### 2.4.4 함수는 그저 코루틴의 특별한 예에 불과하다
- 코루틴이 일시 중지될 때 실행 중인 상태를 저장했다가 저장되었던 상태로 돌아가 다시 시작하는 모습이 마치 운영체제가 스레드를 스케줄링하는 것과 똑같아 보임
- 즉, 사용자 모드(user mode)에서 실행되는 스레드라고 보면됨(**`사용자 상태 스레드`**)
  - 운영체제가 아닌 사용자가 직접 제어해야함 → 코루틴을 통해 개발자는 운영 체제와 유사한 역할을 할 수 있게됨

- 즉, **`사용자는 코루틴을 통해 언제 실행되고 중지될지에 대한 스케줄링의 제어권을 가지게 되어 함수를 제어할 수 있게됨`**

### 2.4.5 코루틴의 역사
- 코루틴은 새롭게 등장한 것이 아님
- 이전에는 스레드가 없었기 때문에 동시성 프로그램을 만들기 위해서는 어쩔수 없이 코루틴과 같은 기술을 사용할 수 밖에 없었음
- 운영체제와 스레드가 등장한 이후, 기본적으로 프로그램의 동시 실행을 지원하기 시작하면서 코루틴은 조용히 묻혀져 갔을 뿐임
- 다만, 최근 인터넷의 발달과 함께 고성능과 동시성을 요구하는 분야가 많아지면서 다시금 주목받기 시작하고 있음

### 2.4.6 코루틴은 어떻게 구현될까?
- **`코루틴의 구현은 사실 스레드의 구현과 본질적으로 차이가 없음`**
- 코루틴이 일시 중지되기 위해서는 **`일시 중지되는 시점에 상태 정보를 반드시 기록해야함`**
- 일반적인 상태 정보는 주로 함수의 스택 프레임에 저장됨(스레드를 위한 영역)
  - `CPU 레지스터 정보`
  - `함수 실행 시 상태 정보`  

- **`코루틴의 스택 프레임은 힙 영역에 저장됨`**

  ![CleanShot 2025-02-02 at 22 38 15@2x](https://github.com/user-attachments/assets/14ba33e5-9d0f-49ea-89f2-ff9862da0235)

- 이론적으로 메모리 공간이 충분하다면, 코루틴 개수에 제한은 없으며 코루틴 간 전환이나 스케줄링은 전적으로 사용자 상태에서 일어나기 때문에 운영체제가 개입할 필요가 없음

#### 코루틴이 중요한 이유(어떤 문제를 해결하는가?)
- 코루틴의 중요한 역할 중 하나는 바로 프로그래머가 **`동기 방식으로 비동기 프로그래밍을 가능하게 해줌`**
