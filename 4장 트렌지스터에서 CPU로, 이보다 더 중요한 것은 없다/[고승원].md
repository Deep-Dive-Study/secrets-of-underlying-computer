# 4장 트렌지스터에서 CPU로, 이보다 더 중요한 것은 없다

# **4.1 이 작은 장난감을 CPU라고 부른다**

**트랜지스터** : 모든 프로그램은 트랜지스터의 개폐 작업으로 완성된다.

- 컴퓨터의 핵심 부품으로, 전류의 흐름을 조절하는 전자 스위치
- 트랜지스터를 이용해 논리 연산을 수행하는 회로를 구성 가능

### **논리 연산의 기본 회로**

- 논리곱(AND) 게이트: 두 입력이 모두 1일 때만 출력이 1
- 논리합(OR) 게이트: 두 입력 중 하나라도 1이면 출력이 1
- 논리부정(NOT) 게이트: 입력의 반대 값을 출력
- 위 세 가지 논리 게이트를 조합하면 모든 논리 연산 구현 가능
- 이를 논리적 완전성(Logical Completeness) 이라 함

### **연산 능력은 어디에서 나올까?**

이진수 덧셈 원리

- 자리 올림수(Carry) 발생 원리
- 두 개의 입력값이 다르면 결과 1, 같으면 0 → XOR 연산
- 자리 올림수는 두 입력값이 모두 1일 때 발생 → AND 연산
- XOR과 AND 게이트를 조합하면 이진 덧셈을 수행하는 가산기(Adder) 구현 가능

산술 논리 장치(ALU)

- CPU의 연산을 담당하는 핵심 모듈
- 덧셈, 뺄셈, 논리 연산 등을 수행

### **신기한 기억 능력**

정보를 저장하는 방법

- 기본적인 논리 게이트만으로는 정보를 일시적으로 저장할 수 없음
- SR Latch (Set-Reset Latch) 를 사용하여 1비트 정보를 저장 가능

레지스터와 메모리의 탄생

- 여러 개의 SR Latch를 조합하면 다수의 비트를 저장할 수 있음
- 이를 발전시켜 레지스터와 메모리 가 등장

### 하드웨어와 소프트웨어의 관계

범용 연산 장치의 필요성

- 특정 기능만 수행하는 하드웨어는 비효율적
- 기본적인 연산 기능만 하드웨어에서 처리하고, 나머지는 소프트웨어로 해결
- 이를 통해 같은 하드웨어로 다양한 기능 수행 가능

명령어 집합(Instruction Set)과 기계 명령어

- CPU는 기계 명령어를 통해 동작
- 기계 명령어는 명령어 + 피연산자 로 구성
- 각 CPU는 고유한 명령어 집합 이용하여 구현됨

### CPU의 실행 원리

클럭 신호와 CPU 동작

- CPU의 동작을 클럭 신호가 조절
- 클럭 신호가 높을수록 CPU는 더 많은 연산을 빠르게 수행 가능 (1초에 레지스터 갱신 횟수)

## 결론

- CPU는 논리 게이트와 트랜지스터를 조합하여 구성
- 연산 장치(ALU), 메모리(Register), 클럭 신호 등을 활용하여 연산 수행
- 명령어 집합(ISA)을 기반으로 소프트웨어와 상호작용
- 컴퓨터의 핵심 동작 원리는 간단한 논리 회로에서 시작

# **4.2 CPU의 유휴 상태와 운영체제의 역할**

### CPU 사용률 확인

- 대부분의 경우 CPU는 실제로 아무 일도 하지 않음
- Windows 작업 관리자를 열면 CPU 사용률이 보통 7~8% 수준
- 게임, 영상 편집, 이미지 처리 작업이 없다면 CPU는 대부분 유휴 상태
- 하지만 사용률이 항상 높다면 소프트웨어 버그 또는 바이러스 감염 가능성 있음

### 프로세스 관리와 스케줄링

프로세스 대기 상태(idle)

- 운영체제는 프로세스를 대기열(queue) 로 관리
- 은행에서 VIP 고객이 우선 처리되는 것처럼 프로세스에도 우선순위 존재

운영체제의 역할

1. 실행할 준비가 된 프로세스를 대기열에 저장
2. 우선순위에 따라 적절한 프로세스를 실행
3. 실행할 프로세스가 없다면 유휴 프로세스를 실행

### 대기열 상태 확인 : 더 나은 설계

유휴 프로세스

- 운영체제는 CPU가 유휴 상태일 때 System Idle Process 를 실행
- 유휴 프로세스는 특별한 연산을 수행하지 않으며, CPU의 전력 소모를 줄이는 역할
- 우선순위가 프로세스중 제일 낮다.

Halt 명령어(HLT)

- CPU가 완전히 멈추지 않도록 Halt(HLT) 명령어를 실행
- 커널상태 CPU로만 실행 가능
- HLT 명령어는 CPU의 일부 모듈을 절전 상태로 전환하여 전력 소비를 줄임
- 하지만 CPU가 완전히 꺼지는 것은 아님
- 제일 많이 실행되는 명령어

CPU의 저전력 모드

- Intel, AMD CPU는 다양한 저전력 모드 제공
- C1~C6 상태: C1은 가벼운 절전 모드, C6은 깊은 절전 모드

### 무한 루프 탈출 : 인터럽트

인터럽트

- CPU가 무한 루프에 빠지지 않도록 외부 이벤트가 발생하면 실행 흐름을 변경하는 기법
- 운영체제는 일정 주기로 타이머 인터럽트(timer interrupt) 를 발생시켜 CPU의 상태를 갱신

인터럽트의 역할

- CPU가 유휴 상태에 빠지더라도 외부 이벤트(마우스, 키보드 입력 등) 가 발생하면 즉시 반응
- 운영체제가 CPU를 다시 활성화하고, 준비된 프로세스를 실행

## 결론

1. CPU가 유휴 상태일 때는 System Idle Process를 실행하여 저전력 상태로 전환
2. Halt 명령어를 사용해 전력 소모를 줄이지만, 완전히 꺼지는 것은 아님
3. 운영체제는 타이머 인터럽트를 활용하여 무한 루프 없이 CPU를 적절히 제어

# **4.3 CPU는 숫자를 어떻게 인식할까?**

### 숫자 0과 양의 정수

- 0의 개념이 수 체계에서 중요한 이유
- 컴퓨터도 위치 기수법을 사용하며 2진법(Binary System) 을 활용

예제:

- 10진법: 5 → 2진법: 101
    - 5 = (1×2²) + (0×2¹) + (1×2⁰)
- 비트(bit) 를 사용하여 표현 가능
- 8비트(1바이트) 사용 시 표현 가능한 범위: 0~255 (2⁸ - 1)

### 부호 있는 정수

- 양의 정수만으로는 부족 → 음수 표현 필요
- 4비트로 표현 가능한 값 개수: 16개(2⁴)
    - 부호 없는 정수: 0~15
    - 부호 있는 정수: 8 ~ 7
- 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 사용 (0: 양수, 1: 음수)

### 부호-크기(Sign-Magnitude) 표현

- 양수에 부호만 추가하는 방식
- 예제 (4비트 표현 기준):
    - `0010` → `+2`
    - `1010` → `-2`

문제점

- 0이 두 가지 존재함 (`0000 = +0`, `1000 = -0`)
- 덧셈, 뺄셈 연산이 복잡함

### 1의 보수

- 모든 비트를 반전시켜 음수 표현
- 예제 (4비트 표현 기준):
    - `0010` → `+2`
    - `1101` → `-2` (1의 보수)

문제점

- 여전히 0이 두 개 존재 (`0000 = +0`, `1111 = -0`)
- 덧셈 시 자리 올림 발생

### 간단하지 않은 두 수 더하기

- 1의 보수 방식에서는 `2 + (-2)` 계산 시 `1111(-0)` 발생
- 별도의 보정 연산 필요

### 2의 보수

- 현대 컴퓨터에서 사용되는 표준 방식
- 1의 보수 방식에서 1을 추가하여 음수를 표현
- 예제 (4비트 표현 기준):
    - `0010` → `+2`
    - `1110` → `-2`

장점

- 0이 하나만 존재 (`0000`)
- 덧셈, 뺄셈을 가산기(Adder)로 처리 가능
- 별도의 보정 연산이 필요 없음

### CPU는 정말 숫자를 알고 있을까?

- CPU는 숫자의 의미를 이해하지 못함
- 단순히 회로 설계 단수화를 위함
- 단순히 0과 1을 조작하는 논리 연산을 수행할 뿐
- 해석은 프로그래머, 컴파일러, 소프트웨어가 담당

### 결론

1. 2진법과 위치 기수법 덕분에 컴퓨터가 숫자를 다룰 수 있음
2. 부호 있는 정수를 표현하기 위해 2의 보수 방식을 사용
3. CPU는 숫자를 이해하는 것이 아니라, 논리 연산을 수행할 뿐

# 4.4 CPU가 if문을 만났을 때

```python
const unsigned arraySize = 10000;
int data[arraySize];

long long sum = 0;

for (unsigned i = 0; i < 100000; ++i) {
	for (unsigned c = 0; c< arraySize; ++c) {
		if(data[c] >= 128) {
			sum += data[c];
		}
	}
}
```

위 코드는 배열의 정렬 여부에 따라 실행 시간이 두 배 이상 차이 난다.

리눅스의 perf 도구를 사용해 초기 단계 분석을 해보자.

![image](https://github.com/user-attachments/assets/763b3782-28b5-432e-9beb-669aa20e32ab)

branch-misses는 분기 예측 실패율을 나타내는 항목이다.

### CPU : 메가팩토리와 파이프라인

- 명령어 인출, 명렁어 해독, 실행, 다시 쓰기 네 단계를 별도의 하드웨어로 처리한다.
- 실제 CPU 내부에서는 기계 명령어 하나를 수십 단계로 분해해서 실행할 수 있다.

### if가 파이프라인을 만나면

1. if문을 컴파일러가 조건부 명령어로 변환한다.
2. 이는 분기 역할을 하는데 참/거짓 여부를 모른다.
3. 파이프라인의 다음 명령어는 뭐가 올지 예측하여 넣는다.
    1. 예측이 맞다면 파이프라인은 계속 흘러간다.
    2. 예측이 틀리다면 이미 실행중인 잘못된 분기 명령어는 전부 무효화 한다. (성능 손실)

따라서 CPU는 정렬된 배열이 추측하기 더 쉽고, 성능 또한 좋다.

분기 예측은 거의 신경쓸 일이 없다.
