# 4장 트렌지스터에서 CPU로, 이보다 더 중요한 것은 없다

# **4.1 이 작은 장난감을 CPU라고 부른다**

**트랜지스터** : 모든 프로그램은 트랜지스터의 개폐 작업으로 완성된다.

- 컴퓨터의 핵심 부품으로, 전류의 흐름을 조절하는 전자 스위치
- 트랜지스터를 이용해 논리 연산을 수행하는 회로를 구성 가능

### **논리 연산의 기본 회로**

- 논리곱(AND) 게이트: 두 입력이 모두 1일 때만 출력이 1
- 논리합(OR) 게이트: 두 입력 중 하나라도 1이면 출력이 1
- 논리부정(NOT) 게이트: 입력의 반대 값을 출력
- 위 세 가지 논리 게이트를 조합하면 모든 논리 연산 구현 가능
- 이를 논리적 완전성(Logical Completeness) 이라 함

### **연산 능력은 어디에서 나올까?**

이진수 덧셈 원리

- 자리 올림수(Carry) 발생 원리
- 두 개의 입력값이 다르면 결과 1, 같으면 0 → XOR 연산
- 자리 올림수는 두 입력값이 모두 1일 때 발생 → AND 연산
- XOR과 AND 게이트를 조합하면 이진 덧셈을 수행하는 가산기(Adder) 구현 가능

산술 논리 장치(ALU)

- CPU의 연산을 담당하는 핵심 모듈
- 덧셈, 뺄셈, 논리 연산 등을 수행

### **신기한 기억 능력**

정보를 저장하는 방법

- 기본적인 논리 게이트만으로는 정보를 일시적으로 저장할 수 없음
- SR Latch (Set-Reset Latch) 를 사용하여 1비트 정보를 저장 가능

레지스터와 메모리의 탄생

- 여러 개의 SR Latch를 조합하면 다수의 비트를 저장할 수 있음
- 이를 발전시켜 레지스터와 메모리 가 등장

### 하드웨어와 소프트웨어의 관계

범용 연산 장치의 필요성

- 특정 기능만 수행하는 하드웨어는 비효율적
- 기본적인 연산 기능만 하드웨어에서 처리하고, 나머지는 소프트웨어로 해결
- 이를 통해 같은 하드웨어로 다양한 기능 수행 가능

명령어 집합(Instruction Set)과 기계 명령어

- CPU는 기계 명령어를 통해 동작
- 기계 명령어는 명령어 + 피연산자 로 구성
- 각 CPU는 고유한 명령어 집합 이용하여 구현됨

### CPU의 실행 원리

클럭 신호와 CPU 동작

- CPU의 동작을 클럭 신호가 조절
- 클럭 신호가 높을수록 CPU는 더 많은 연산을 빠르게 수행 가능 (1초에 레지스터 갱신 횟수)

## 결론

- CPU는 논리 게이트와 트랜지스터를 조합하여 구성
- 연산 장치(ALU), 메모리(Register), 클럭 신호 등을 활용하여 연산 수행
- 명령어 집합(ISA)을 기반으로 소프트웨어와 상호작용
- 컴퓨터의 핵심 동작 원리는 간단한 논리 회로에서 시작

# **4.2 CPU의 유휴 상태와 운영체제의 역할**

### CPU 사용률 확인

- 대부분의 경우 CPU는 실제로 아무 일도 하지 않음
- Windows 작업 관리자를 열면 CPU 사용률이 보통 7~8% 수준
- 게임, 영상 편집, 이미지 처리 작업이 없다면 CPU는 대부분 유휴 상태
- 하지만 사용률이 항상 높다면 소프트웨어 버그 또는 바이러스 감염 가능성 있음

### 프로세스 관리와 스케줄링

프로세스 대기 상태(idle)

- 운영체제는 프로세스를 대기열(queue) 로 관리
- 은행에서 VIP 고객이 우선 처리되는 것처럼 프로세스에도 우선순위 존재

운영체제의 역할

1. 실행할 준비가 된 프로세스를 대기열에 저장
2. 우선순위에 따라 적절한 프로세스를 실행
3. 실행할 프로세스가 없다면 유휴 프로세스를 실행

### 대기열 상태 확인 : 더 나은 설계

유휴 프로세스

- 운영체제는 CPU가 유휴 상태일 때 System Idle Process 를 실행
- 유휴 프로세스는 특별한 연산을 수행하지 않으며, CPU의 전력 소모를 줄이는 역할
- 우선순위가 프로세스중 제일 낮다.

Halt 명령어(HLT)

- CPU가 완전히 멈추지 않도록 Halt(HLT) 명령어를 실행
- 커널상태 CPU로만 실행 가능
- HLT 명령어는 CPU의 일부 모듈을 절전 상태로 전환하여 전력 소비를 줄임
- 하지만 CPU가 완전히 꺼지는 것은 아님
- 제일 많이 실행되는 명령어

CPU의 저전력 모드

- Intel, AMD CPU는 다양한 저전력 모드 제공
- C1~C6 상태: C1은 가벼운 절전 모드, C6은 깊은 절전 모드

### 무한 루프 탈출 : 인터럽트

인터럽트

- CPU가 무한 루프에 빠지지 않도록 외부 이벤트가 발생하면 실행 흐름을 변경하는 기법
- 운영체제는 일정 주기로 타이머 인터럽트(timer interrupt) 를 발생시켜 CPU의 상태를 갱신

인터럽트의 역할

- CPU가 유휴 상태에 빠지더라도 외부 이벤트(마우스, 키보드 입력 등) 가 발생하면 즉시 반응
- 운영체제가 CPU를 다시 활성화하고, 준비된 프로세스를 실행

## 결론

1. CPU가 유휴 상태일 때는 System Idle Process를 실행하여 저전력 상태로 전환
2. Halt 명령어를 사용해 전력 소모를 줄이지만, 완전히 꺼지는 것은 아님
3. 운영체제는 타이머 인터럽트를 활용하여 무한 루프 없이 CPU를 적절히 제어

# **4.3 CPU는 숫자를 어떻게 인식할까?**

### 숫자 0과 양의 정수

- 0의 개념이 수 체계에서 중요한 이유
- 컴퓨터도 위치 기수법을 사용하며 2진법(Binary System) 을 활용

예제:

- 10진법: 5 → 2진법: 101
    - 5 = (1×2²) + (0×2¹) + (1×2⁰)
- 비트(bit) 를 사용하여 표현 가능
- 8비트(1바이트) 사용 시 표현 가능한 범위: 0~255 (2⁸ - 1)

### 부호 있는 정수

- 양의 정수만으로는 부족 → 음수 표현 필요
- 4비트로 표현 가능한 값 개수: 16개(2⁴)
    - 부호 없는 정수: 0~15
    - 부호 있는 정수: 8 ~ 7
- 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 사용 (0: 양수, 1: 음수)

### 부호-크기(Sign-Magnitude) 표현

- 양수에 부호만 추가하는 방식
- 예제 (4비트 표현 기준):
    - `0010` → `+2`
    - `1010` → `-2`

문제점

- 0이 두 가지 존재함 (`0000 = +0`, `1000 = -0`)
- 덧셈, 뺄셈 연산이 복잡함

### 1의 보수

- 모든 비트를 반전시켜 음수 표현
- 예제 (4비트 표현 기준):
    - `0010` → `+2`
    - `1101` → `-2` (1의 보수)

문제점

- 여전히 0이 두 개 존재 (`0000 = +0`, `1111 = -0`)
- 덧셈 시 자리 올림 발생

### 간단하지 않은 두 수 더하기

- 1의 보수 방식에서는 `2 + (-2)` 계산 시 `1111(-0)` 발생
- 별도의 보정 연산 필요

### 2의 보수

- 현대 컴퓨터에서 사용되는 표준 방식
- 1의 보수 방식에서 1을 추가하여 음수를 표현
- 예제 (4비트 표현 기준):
    - `0010` → `+2`
    - `1110` → `-2`

장점

- 0이 하나만 존재 (`0000`)
- 덧셈, 뺄셈을 가산기(Adder)로 처리 가능
- 별도의 보정 연산이 필요 없음

### CPU는 정말 숫자를 알고 있을까?

- CPU는 숫자의 의미를 이해하지 못함
- 단순히 회로 설계 단수화를 위함
- 단순히 0과 1을 조작하는 논리 연산을 수행할 뿐
- 해석은 프로그래머, 컴파일러, 소프트웨어가 담당

### 결론

1. 2진법과 위치 기수법 덕분에 컴퓨터가 숫자를 다룰 수 있음
2. 부호 있는 정수를 표현하기 위해 2의 보수 방식을 사용
3. CPU는 숫자를 이해하는 것이 아니라, 논리 연산을 수행할 뿐

# 4.4 CPU가 if문을 만났을 때

```python
const unsigned arraySize = 10000;
int data[arraySize];

long long sum = 0;

for (unsigned i = 0; i < 100000; ++i) {
	for (unsigned c = 0; c< arraySize; ++c) {
		if(data[c] >= 128) {
			sum += data[c];
		}
	}
}
```

위 코드는 배열의 정렬 여부에 따라 실행 시간이 두 배 이상 차이 난다.

리눅스의 perf 도구를 사용해 초기 단계 분석을 해보자.

![image](https://github.com/user-attachments/assets/763b3782-28b5-432e-9beb-669aa20e32ab)

branch-misses는 분기 예측 실패율을 나타내는 항목이다.

### CPU : 메가팩토리와 파이프라인

- 명령어 인출, 명렁어 해독, 실행, 다시 쓰기 네 단계를 별도의 하드웨어로 처리한다.
- 실제 CPU 내부에서는 기계 명령어 하나를 수십 단계로 분해해서 실행할 수 있다.

### if가 파이프라인을 만나면

1. if문을 컴파일러가 조건부 명령어로 변환한다.
2. 이는 분기 역할을 하는데 참/거짓 여부를 모른다.
3. 파이프라인의 다음 명령어는 뭐가 올지 예측하여 넣는다.
    1. 예측이 맞다면 파이프라인은 계속 흘러간다.
    2. 예측이 틀리다면 이미 실행중인 잘못된 분기 명령어는 전부 무효화 한다. (성능 손실)

따라서 CPU는 정렬된 배열이 추측하기 더 쉽고, 성능 또한 좋다.

분기 예측은 거의 신경쓸 일이 없다.

# 4.5 CPU 코어 수와 스레드 수 사이의 관계는 무엇일까?

### CPU와 스레드의 관계

- CPU 코어 수와 스레드 수 사이에는 어떠한 관계도 없다.
- CPU는 요리사, 스레드는 요리라고 비유 가능
- 요리사(코어)는 여러 요리를 만들 수 있고, 각 요리는 특정 레시피(스레드)를 따름
- CPU는 실행 중인 모든 명령어가 특정 스레드에 속한다고 생각하지 않음
- 운영체제가 각 명령어가 속한 스레드를 관리할 뿐

**CPU와 스레드의 차이**

| 개념 | 하드웨어(CPU) | 소프트웨어(스레드) |
| --- | --- | --- |
| 역할 | 기계 명령어 실행 | 실행 흐름 관리 |
| 개수 | 물리적 코어 개수 제한 | 코어 수와 무관하게 여러 개 생성 가능 |
| 관리 주체 | 자체적으로 수행 | 운영체제가 관리 |

### 작업 분할과 블로킹 입출력

**스레드를 사용하는 이유**

- 단일 코어 환경에서도 다중 스레드는 코드 작성 및 관리에 유리
- 스레드를 사용하면 작업이 대기 없이 진행 가능
- 예제: 그래픽 UI + 계산 연산
    - UI 스레드에서 계산을 수행하면 인터페이스가 멈춤
    - 계산 작업을 별도 스레드에서 실행하면 UI가 부드럽게 유지됨

**블로킹 입출력 처리**

- 블로킹 호출이 실행되면 스레드가 정지됨
- 이를 별도 스레드에서 실행하면 프로그램이 멈추지 않음

### 다중 코어와 다중 스레드

- 스레드는 많다고 무조건 좋은 것이 아님
    - 순수 계산 작업: 코어당 스레드 1개가 이상적
    - 입출력 및 동기화 포함 작업: 적절한 추가 스레드 필요
- 스레드 개수가 많아지면 운영체제의 문맥 전환 비용 증가 → 성능 저하 가능

# 4.6 CPU 진화론(상): 복잡 명령어 집합의 탄생

### 프로그래머의 눈에 보이는 CPU

- 모든 프로그램은 결국 기계 명령어로 변환됨
- CPU는 단순히 메모리에서 명령어를 읽어 실행할 뿐

### CPU의 능력 범위: 명령어 집합(ISA)

- CPU의 기능은 명령어 집합(ISA, Instruction Set Architecture) 에 의해 결정됨
- 예제:
    - `ADD`: 덧셈 수행
    - `MOV`: 메모리 → 레지스터 데이터 이동
    - `JMP`: 특정 위치로 이동

명령어 집합이 중요한 이유

- 프로그램이 CPU에서 실행될 수 있는지 결정
- CPU의 하드웨어 설계에 직접적인 영향을 미침

### 추상화: 적을수록 좋다

- 1970년대까지 많은 프로그램이 어셈블리어로 작성됨
- 당시에는 프로그래머가 직접 CPU 명령어를 사용해야 했음
- 고급 언어가 등장하면서 프로그래머는 CPU 명령어를 신경 쓰지 않아도 됨

의미상 간격(Semantic Gap) 개념

- 프로그래머가 사용하는 고급 언어와 CPU가 실행하는 기계 명령어 간 차이
- 이 간격을 줄이기 위해 복잡 명령어 집합(CISC)이 등장

### 코드도 저장 공간을 차지한다

- 1970년대 메모리는 매우 제한적(수 KB 수준)
- 프로그램 크기를 줄이기 위해 하나의 명령어로 더 많은 작업을 수행하는 방식 채택
- 결과적으로 복잡 명령어 집합(CISC) 설계가 발전

### 필연적인 복잡 명령어 집합의 탄생

- 더 많은 기능을 가진 명령어가 필요해짐
- CPU 내부에서 복잡한 연산을 직접 수행하는 방식으로 발전
- 마이크로코드(Microcode) 개념 도입
    - CPU 내부에서 명령어를 해석하고 실행
    - 하드웨어를 직접 수정하지 않고 명령어 추가 가능
    - 문제점
        - 마이크로코드가 버그를 유발할 수 있음
        - 복잡한 설계로 인해 CPU 성능 저하

결론

- 복잡 명령어 집합은 프로그래머에게 편리하지만, CPU 설계는 점점 어려워짐
- 이후 축소 명령어 집합(RISC) 개념이 등장

# 4.7 CPU 진화론(중): 축소 명령어 집합의 탄생

### 복잡함을 단순함으로

- 파레토 법칙 적용
    - CPU가 사용하는 명령어 중 80%의 시간 동안 20%의 명령어만 실행됨
- 불필요한 복잡한 명령어를 제거하면 CPU 성능을 높일 수 있음

### 축소 명령어 집합(RISC) 철학

- 명령어 자체 단순화
    - 복잡한 명령어 대신 여러 개의 단순한 명령어 사용
- 컴파일러 중심 설계
    - 컴파일러가 최적의 명령어를 조합하여 사용
- LOAD/STORE 구조
    - 메모리 접근을 최소화하여 CPU 성능 향상

### 복잡 명령어 집합 vs 축소 명령어 집합

|  | **복잡 명령어 집합 (CISC)** | **축소 명령어 집합 (RISC)** |
| --- | --- | --- |
| 명령어 개수 | 많음 | 적음 |
| 명령어 길이 | 가변적 | 고정 |
| 연산 방식 | 하나의 명령어로 복잡한 작업 수행 | 여러 개의 단순한 명령어 조합 |
| 파이프라인 활용 | 어려움 | 쉬움 |
| 대표적인 CPU | 인텔 x86 | ARM, MIPS |

### 명령어 파이프라인

- 명령어를 여러 단계로 나누어 실행 속도를 높이는 기술
- RISC CPU에서 더욱 효과적으로 활용됨

# **4.8 CPU 진화론(하) : 절체절명의 위기에서 반격**

### 이길 수 없다면 함께하라 (RISC와 동일한 CISC)

- CISC(복잡 명령어 집합) 의 단점: 파이프라인 최적화가 어려움
- 해결책: CISC 명령어를 내부적으로 RISC 방식으로 변환
    - 마이크로 명령어(micro-operation) 개념 도입
    - CISC 명령어를 여러 개의 간단한 RISC 유사 명령어로 변환 후 실행
- 겉으로는 CISC를 유지하면서도 RISC의 장점을 활용
- x86 CPU도 내부적으로는 RISC 방식과 유사하게 동작

### 하이퍼스레딩이라는 필살기

- 기존 CPU는 한 번에 하나의 스레드만 실행 가능
- 하이퍼스레딩(HT, Hyper-Threading) 은 CPU 코어 하나가 두 개의 논리적 스레드를 실행하도록 함

**하이퍼스레딩의 원리**

- CPU 내부 리소스 활용률을 극대화 하는 방법이다.
- 기존의 파이프라인에 빈 공간이 있어 다른 스레드의 명령어가 이를 채워주는 방법이다.
- 운영체제는 CPU 코어가 두 개처럼 보이지만, 실제로는 하나이다.

### CISC와 RISC의 통합

CISC와 RISC는 점점 닮아가는 구조로 발전

- CISC: 내부적으로 RISC 방식 도입
- RISC: 고성능 CPU에서 CISC의 일부 요소 도입

여전히 차이가 존재

- RISC는 컴파일러 의존성이 높고, 명령어 길이가 일정
- CISC는 기존 소프트웨어와의 호환성이 강점

### CISC와 RISC 간 상업적 전쟁

- 기술만으로 시장이 결정되는 것은 아님
- x86(CISC) 진영(인텔)은 소프트웨어 생태계를 활용하여 시장을 장악
- 2000년대 이후 ARM(RISC, 애플) 프로세서가 모바일 시장을 장악하면서 새로운 경쟁 구도 형성

결론

- x86(CISC)은 여전히 데스크톱/서버 시장을 지배
- ARM(RISC)은 모바일 시장을 장악하고, 최근에는 데스크톱 시장까지 확장

# 4.9 CPU, 스택과 함수 호출, 시스템 호출, 스레드 전환, 인터럽트 처리 통달하기

### 레지스터

- CPU는 레지스터를 활용하여 속도를 극대화
- 메모리보다 100배 이상 빠르며, 필수적인 중간 저장 공간 역할

### 스택 포인터

- 스택(stack) 은 함수 호출 시 로컬 변수와 실행 정보 저장
- 스택 포인터(Stack Pointer, SP) 를 사용하여 스택의 최상단을 관리
- 함수가 호출될 때마다 새로운 스택 프레임(Stack Frame)이 생성
- 후입선출(LIFO) 방식 으로 동작

### 명령어 주소 레지스터(PC, 프로그램 카운터)

- PC(Program Counter): CPU가 실행할 다음 명령어의 주소 저장
- 함수 호출이나 조건문 실행 시 점프(Jump) 명령어를 통해 변경됨

### 상태 레지스터

- 연산 결과에 대한 자리올림(Carry), 오버플로(Overflow) 등 상태 정보 저장
- CPU가 사용자 모드 ↔ 커널 모드 전환 시에도 사용

### 상황 정보(Context)

- CPU가 실행 상태를 중단하고 다시 복구하기 위해 상황 정보를 저장
- Context Switching에 필수적

### 중첩과 스택

- 스택은 후입선출(LIFO) 방식으로 동작
- 함수 호출, 인터럽트 처리, 시스템 호출 모두 스택을 이용하여 실행 상태를 관리

### 함수 호출과 실행 시간 스택

- 함수 실행 중에는 반환 주소, 지역 변수 등이 스택 프레임에 저장됨
- 함수 실행이 끝나면 스택 프레임을 제거하고 원래 함수로 복귀

### 시스템 호출과 커널 상태 스택

- 시스템 호출(System Call): 응용 프로그램이 운영체제의 기능을 요청하는 과정
- 시스템 호출 시 사용자 스택이 아닌 커널 스택을 사용

### 인터럽트와 인터럽트 함수 스택

인터럽트 : 외부 장치(키보드, 마우스, 네트워크 등)로부터 요청이 발생하면 CPU가 실행 중인 작업을 잠시 중단하고 처리

- 인터럽트 발생 시 CPU는 현재 실행 중인 작업을 저장하고 인터럽트 핸들러로 이동
- 인터럽트 실행 후 원래 작업으로 복귀

**인터럽트의 실행 과정**

1. 현재 실행 중인 명령어 저장
    - CPU는 현재 실행 중인 프로그램(프로세스)의 상태를 저장해야 함
    - 프로그램 카운터(PC, 다음 실행할 명령어의 주소)와 레지스터 값을 스택에 저장
2. 인터럽트 핸들러 실행 (ISR, Interrupt Service Routine)
    - 인터럽트 유형에 따라 특정 핸들러가 실행됨
    - 예: 키보드 입력 → 키보드 인터럽트 핸들러 실행
3. 원래 실행 중이던 코드로 복귀
    - 인터럽트 핸들러 실행 후, 저장해둔 레지스터 값과 프로그램 카운터를 복원
    - CPU는 원래 수행 중이던 작업을 계속 실행

![image](https://github.com/user-attachments/assets/4e89bf82-512e-4af3-8e23-a649b2c6e5a0)

### 스레드 전환과 커널 상태 스택

- 멀티스레딩 환경에서 CPU가 실행 중인 스레드를 변경하는 과정
- Context Switch시 현재 실행 중인 스레드의 정보 저장 후 새로운 스레드 실행
- 운영체제는 각 스레드마다 별도의 커널 스택을 유지

**Context Switch 과정**

1. 현재 실행 중인 스레드의 상태 저장
    - 실행 중이던 스레드의 레지스터 값, 프로그램 카운터(PC), 스택 포인터(SP) 등을 저장
    - 커널 스택(Kernel Stack) 에 저장됨
2. 새로운 스레드의 상태 복원
    - 새롭게 실행할 스레드의 이전 상태를 복구
    - 해당 스레드의 레지스터 값, 프로그램 카운터, 스택 포인터 등을 로드
3. 새로운 스레드 실행
    - CPU는 새로운 스레드의 명령어를 실행
    - 이전 스레드는 이후 다시 실행될 때 상태를 복구함

![image](https://github.com/user-attachments/assets/b5af52c2-cbd7-41ca-adeb-f74358264a2b)

Context Switching이 발생하는 경우

1. CPU 스케줄링 (멀티태스킹)
2. 스레드가 I/O 작업을 수행하는 경우
3. 우선순위 변경 (Priority Scheduling)

# 4.10 요약

CPU는 메모리에서 명령어를 가져와 실행하는 단순한 역할을 수행

실행 중인 코드의 흐름을 변경하는 주요 개념

- 함수 호출: 프로그램 내에서 특정 코드 블록을 실행한 후 복귀
- 시스템 호출: 운영체제 기능을 요청 (예: 파일 읽기, 네트워크 요청)
- 인터럽트 처리: 외부 장치의 신호를 처리 (예: 키보드 입력)
- 스레드 전환: 실행 중인 작업을 다른 작업으로 변경

결론

- CPU의 실행 흐름 전환은 스택과 Context Switch에 의해 관리됨
- 운영체제는 스택을 활용하여 안정적으로 실행 상태를 관리
